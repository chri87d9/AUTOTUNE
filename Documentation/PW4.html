<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>PW4 API documentation</title>
<meta name="description" content="Author: Hasse Straede Hansen
Mail: hasse302@hotmail.com â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PW4</code></h1>
</header>
<section id="section-intro">
<p>Author: Hasse Straede Hansen
Mail: hasse302@hotmail.com</p>
<p>PW4 is a module for HTTP communication between a daemon (server and client) and PWI4, the telescope operating software from PlaneWave Instruments.
The module is built into functions where each function has a small description, what arguments it takes and what it returns.</p>
<p>Currently on version 0.0.1 as of 27/07/2020.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Author: Hasse Straede Hansen 
Mail: hasse302@hotmail.com

PW4 is a module for HTTP communication between a daemon (server and client) and PWI4, the telescope operating software from PlaneWave Instruments. 
The module is built into functions where each function has a small description, what arguments it takes and what it returns.

Currently on version 0.0.1 as of 27/07/2020.

&#34;&#34;&#34;
import numpy as np
import requests
import time
from time import ctime
import numpy as np
from xml.etree import ElementTree as ET
import song_star_checker_AUTOTUNE as SSCA
import re
import datetime
import json
from RaConverter import *
import PWI4_config as conf


class PWI4():   
    def __init__(self):
        &#34;&#34;&#34;
        This function initializes the connection to PWI4. 
        It also defines names for the variables from PWI4, which are stored in self. 
        
        Args:
            None

        Returns: True
        &#34;&#34;&#34;
        ##this is the IP address of PWI4
        self.link=&#34;http://%s:%i/&#34;%(conf.NOVO_tel_com_ip,conf.NOVO_tel_com_port)
        status = requests.get(self.link+&#34;status&#34;)
    
        
        data = status.text.split(&#39;\n&#39;)
        self.status = status.text
        self.data = data

        #site parameters
        self.site_latitude = data[1].split(&#39;=&#39;)[1] #latitude of position of the telescope
        self.site_longitude = data[2].split(&#39;=&#39;)[1] #longitude of the position of the telescope
        self.site_elevation = data[3].split(&#39;=&#39;)[1] #elevation at position of telescope
        self.site_lmst = data[4].split(&#39;=&#39;)[1] #local mean sidereal time
        
        #Focuser
        self.FOC_connection = data[36].split(&#39;=&#39;)[1]
        self.FOC_pos = data[38].split(&#39;=&#39;)[1]
        self.FOC_moving = data[39].split(&#39;=&#39;)[1]


        #Rotator
        self.ROT_connection = data[40].split(&#39;=&#39;)[1]
        self.ROT_moving = data[44].split(&#39;=&#39;)[1]
        self.ROT_mechanial_pos = data[42].split(&#39;=&#39;)[1]
        self.ROT_pos = data[43].split(&#39;=&#39;)[1]
        self.ROT_derotate_enabled = data[41].split(&#39;=&#39;)[1]

        #Mount
        self.MNT_connection = data[5].split(&#39;=&#39;)[1] #true/false
        self.MNT_slewing = data[15].split(&#39;=&#39;)[1] #True/False
        self.MNT_Alt = data[14].split(&#39;=&#39;)[1] #in deg
        self.MNT_Azm = data[13].split(&#39;=&#39;)[1] #in deg
        self.MNT_Ra2000 = data[9].split(&#39;=&#39;)[1] #in hours
        self.MNT_Dec2000 = data[10].split(&#39;=&#39;)[1] #in degrees
        self.MNT_tracking = data[16].split(&#39;=&#39;)[1] #true/false
        self.MNT_AltMotor = data[27].split(&#39;=&#39;)[1] #enabled/disabled given by True/False
        self.MNT_AzmMotor = data[22].split(&#39;=&#39;)[1] #enabled/Disabled given by True/False
        self.MNT_PointingModel = data[32].split(&#39;=&#39;)[1] #filename of current pointing model
        self.MNT_PointingModelPoints = data[33].split(&#39;=&#39;)[1] #Number of points in pointing model
        self.MNT_PointingModelError = data[35].split(&#39;=&#39;)[1] #Error of pointing model in arcsec
        self.MNT_AltRMSErrorArcsec = data[23].split(&#39;=&#39;)[1] #Error on pointing in Arcsec on the altitude motor
        self.MNT_AzmRMSErrorArcsec = data[28].split(&#39;=&#39;)[1] #Error on pointing in Arcsec on the azimuth motor
        



        #Setting the different values with a &#34;human-readable&#34; naming-scheme.

        #Status (times)
    #     self.STAT_utc = self.tree[0][0].text
    #     self.STAT_lst = self.tree[0][1].text
    #     self.STAT_jd  = self.tree[0][2].text

    #     #Focuser
    #     self.Foc_connection = self.tree[1][0].text
    #     self.Foc_pos = self.tree[1][1].text
    #     self.Foc_move = self.tree[1][3].text
    #     self.Foc_complete = self.tree[1][4].text
    #     self.Foc_homing = self.tree[1][5].text

    #     #Rotator
    #     self.ROT_connection = self.tree[4][0].text
    #     self.ROT_position = self.tree[4][1].text
    #     self.ROT_moving = self.tree[4][3].text 
    #     self.ROT_goToComplete = self.tree[4][4].text
    #     self.ROT_homing = self.tree[4][5].text
    #     self.ROT_AltAzDerotate = self.tree[4][6].text
        
    #     #Mount
    #     self.MNT_connection = self.tree[7][0].text
    #     self.MNT_on_target  = self.tree[7][1].text
    #     self.MNT_moving = self.tree[7][3].text
    #     self.MNT_tracking = self.tree[7][3].text
    #     self.MNT_Ra2000 = self.tree[7][8].text
    #     self.MNT_Dec2000 = self.tree[7][9].text
    #     self.MNT_Alt = self.tree[7][13].text
    #     self.MNT_Azm = self.tree[7][12].text
    #     self.MNT_AzmMotor = self.tree[7][20].text
    #     self.MNT_AltMotor = self.tree[7][21].text
    #     self.MNT_PointingModel = self.tree[7][22].text
    #     self.MNT_AzmMotorError = self.tree[7][16].text
    #     self.MNT_AltMotorError = self.tree[7][17].text
    #     self.MNT_AltRMSErrorArcsec = self.tree[7][15].text
    #     self.MNT_AzmRMSErrorArcsec = self.tree[7][14].text


        
    #    #Temperatures - NEEDS WORKING! DROPS OUT WHEN FOCUSER DISCONNECT
    #     if self.Foc_connection == &#34;True&#34;:
    #        try:
    #            self.TEMP_pri = self.tree[9][0].text
    #            self.TEMP_amb = self.tree[9][1].text
    #            self.TEMP_sec = self.tree[9][2].text
    #            self.TEMP_backp = self.tree[9][3].text
    #            self.TEMP_m3 = self.tree[9][4].text
    #        except:
    #            print(&#39;There was an issue connecting the temperature sensors for the mirrors.&#39;)

    #     #Fans
    #     self.FANS_state = self.tree[10][0].text

    def update(self):
        &#34;&#34;&#34;
        This function runs the __init__ function again to update the stored variables in self. 
        
        Args:
            None

        Returns: 
            True
        
        &#34;&#34;&#34;
        self.__init__()
        return True


    def getALL(self):
        &#34;&#34;&#34;
        Prints all data that is available from PWI4 is a list. 
        
        Args:
            None

        Returns: 
            A list of parameters and their values
        &#34;&#34;&#34;
        self.update()
        ALL=self.status
        print(ALL)
        return ALL

    def getRA2000(self):
        &#34;&#34;&#34;
        A function that prints the current Right Ascension (RA) in the J2000 epoch of the mount/telescope.
        
        Args:
            None

        Returns:
            RA_J2000 in the format HH:MM:SS
        &#34;&#34;&#34;
        self.update()
        RA = self.MNT_Ra2000

        RA_hour = RAconverter_DectoHH(float(RA))
        return RA_hour
    
    def getDEC2000(self):
        &#34;&#34;&#34;
        A function that prints the current Declination (DEC) in the J2000 epoch of the mount/telescope.
        
        Args:
            None

        Returns:
            DEC_J2000 in the format DD:MM:SS
        &#34;&#34;&#34;
        
        self.update()
        DEC = self.MNT_Dec2000
        DEC_hour = DecConverter_DecitoDD(float(DEC))
        return DEC_hour
    

    def getFocuserPos(self):
        &#34;&#34;&#34;
        A function that prints the current position of the focuser in the telscope. 
        The units of the position is in microns.
        
        Args:
            None

        Returns:
            The position of the focuser in microns if the focuser is connected
            If the focuser is not connected, a reply is sent about the focuser not being connected
        &#34;&#34;&#34;
        self.update()
        if self.FOC_connection == &#34;true&#34;:
            print(&#39;The current position of the focuser is %s microns&#39;%(self.FOC_pos))
            reply = &#34;The current position of the focuser is %s microns&#34;%(self.FOC_pos)
            return reply
        else:
            print(&#39;The focuser is not connected to PWI4. Please use .ConnectFOC() to connect the focuser to PWI4.&#39;)
            reply = &#39;The focuser is not connected to PWI4. Please use .ConnectFOC() to connect the focuser to PWI4.&#39;
            return reply

    def getRotatorPos(self):
        &#34;&#34;&#34;
        A function that prints the current position of the rotator.
        The units of the position of the rotator is in degrees. 

        Args:
            None
        
        Returns:
            The current position of the rotator in degrees
        &#34;&#34;&#34;
        self.update()
        if self.ROT_connection == &#34;true&#34;:
            print(&#39;The current position of the rotator is %s degrees&#39;%(self.ROT_pos))
            reply = &#39;The current position of the rotator is %s degrees&#39;%(self.ROT_pos)
            return reply
        else:
            print(&#34;The rotator is not connected to PWI. Try the command: ConnectFOC()  &#34;)
            reply = &#39;The rotator is not connected to PWI. Try the command: ConnectFOC() &#39;
            return reply
    
    def getStatus(self):
        &#34;&#34;&#34;
        Prints a status message with the current RA and DEC in J2000 epoch, the 
        current UTC time. The message also gives a message whehter the telescope 
        is moving and/or tracking. Finally it prints whether the mount, focuser and rotator is
        connected to the PWI. 
        
        Args:
            None

        Returns:
            The status message
        
        &#34;&#34;&#34;
        self.update()
        RA = self.MNT_Ra2000
        DEC = self.MNT_Dec2000
        Alt = self.MNT_Alt
        Azm = self.MNT_Azm
        Moving = self.MNT_slewing
        Mnt = self.MNT_connection
        Foc = self.FOC_connection
        tracking = self.MNT_tracking
        Rot = self.ROT_connection
        
        
        reply = &#34;The telescope is pointed at RA: %s, DEC:%s (J2000) / Alt: %.4f, Azm: %.4f. \n&#34; %(RA,DEC,float(Alt),float(Azm))
        print(&#39;The telescope is pointed at RA: %s, DEC:%s (J2000) / Alt: %.4f, Azm: %.4f.&#39; %(RA,DEC,float(Alt),float(Azm)))

        if Moving == &#34;False&#34;:
            print(&#39;The telescope is not moving.&#39;)
            reply += &#39;The telescope is not moving.\n&#39;
        elif Moving == &#34;True&#34;:
            print(&#39;The telescope is moving.&#39;)
            reply += &#39;The telescope is moving.\n&#39;
            
        if tracking == &#34;True&#34;:
            print(&#39;The telescope is tracking.&#39;)
            reply += &#39;The telescope is tracking \n&#39;
        elif tracking == &#34;False&#34;:
            print(&#39;The telescope is NOT tracking.&#39;)
            reply += &#39;The telescope is NOT tracking \n&#39;
       
        
        print(&#39;Connections: \n&#39;)
        reply += &#39;Connections: \n&#39;
        if Mnt == &#34;true&#34;:
            print(&#39;The mount is connected to PWI&#39;)
            reply += &#39;The mount is connected to PWI \n&#39;
        elif Mnt == &#34;false&#34;:
            print(&#39;The mount is NOT connected to PWI&#39;)
            print(&#39;You should try connecting the mount with PWI using the command: .ConnectMNT()\n&#39;)
            reply += &#39;The mount is NOT connected to PWI \n&#39; 
            reply += &#39;You should try connecting the mount with PWI using the command: .ConnectMNT() \n&#39;
            
            
        if Foc == &#34;true&#34;:
            print(&#39;The focuser is connected to PWI&#39;)
            reply += &#39;The focuser is connected to PWI \n&#39;
        elif Foc == &#34;false&#34;:
            print(&#39;The focuser is NOT connected to PWI&#39;)
            print(&#39;You should try connecting the focuser with the command: .ConnectFOC()\n&#39;)
            reply += &#39;The focuser is NOT connected to PWI\n&#39;
            reply += &#39;You should try connecting the focuser with the command: .ConnectFOC() \n&#39;
            
        if Rot == &#34;true&#34;:
            print(&#39;The rotator is connected to PWI&#39;)
            reply += &#39;The rotator is connected to PWI\n&#39;
        elif Rot == &#34;false&#34;:
            print(&#39;The rotator is NOT connected to PWI&#39;)
            print(&#39;The rotator and focuser is linked in their connection.&#39;)
            print(&#39;You should maybe try to reconnect the focuser and theirby reconnect the rotator wit----h the functions: .DisconnectFOC() and .ConnectFOC()\n&#39;)
            reply += &#39;The rotator is NOT connected to PWI \n&#39;
            reply += &#39;The rotator and focuser is linked in their connection. \n&#39;
            reply += &#39;You should maybe try to reconnect the focuser and theirby reconnect the rotator with the functions: .DisconnectFOC() and .ConnectFOC() \n&#39;
        
        return reply
    

    def getMNT_CONNECT(self):
        &#34;&#34;&#34;
        A function that checks the connection between PWI and the mount of telescope.
        
        Args:
            None

        Returns:
            True if the mount is connected
            False if the mount is not connected
            False if the mount state is neither connected nor disconnected
        &#34;&#34;&#34;
        self.update()
        if self.MNT_connection == &#34;true&#34;:
            print(&#34;Mount is connected&#34;)
            return True
        if self.MNT_connection == &#34;false&#34;:
            print(&#34;Mount is NOT connected&#34;)
            return False
        else:
            print(&#34;ERROR: Mount state unable to be read!&#34;)
            return False


    def getFOC_CONNECT(self):
        &#34;&#34;&#34;
        A function that checks the connection between PWI and the focuser.

        Args:
            None
        
        Returns:
            True if the focuser is connected to PWI4
            False if the focuser is not connected to PWI4
            False if the focuser connection could not be reached
        &#34;&#34;&#34;
        self.update()
        
        if self.FOC_connection == &#34;true&#34;:
            print(&#34;Focuser is connected&#34;)
            return True
        if self.FOC_connection == &#34;false&#34;:
            print(&#34;Focuser is NOT connected&#34;)
            return False
        else:
            print(&#34;ERROR: Connection to focuser is not reachable&#34;)
            return False

    def getROT_CONNECT(self):
        &#34;&#34;&#34;
        A functions that checks the connection between PWI and the rotator. 
        Please note that the focuser and rotator are connected such that
        the focuser and rotator share the same connection to PWI. 
        So if the rotator is not connected, then the focuser won&#39;t bet connected either. 

        Args:
            None
        
        Returns:
            True when the rotator is connected to PWI4
            False when the rotator is not connected to PWI4
        &#34;&#34;&#34;

        self.update()
        
        if self.ROT_connection == &#34;true&#34;:
            print(&#34;Rotator is connected&#34;)
            return self.ROT_connection
        if self.ROT_connection == &#34;false&#34;:
            print(&#34;Rotator is not connected&#34;)
            return False
        else:
            print(&#34;ERROR: Rotator connection is not reachable.&#34;)
            return False

    def getIsTrackingOn(self):
        &#34;&#34;&#34;
        A function that checks if the telescope is tracking a target.

        Args:
            None
        
        Returns:
            True when the tracking is on
            False when the tracking is off
        &#34;&#34;&#34;
        self.update()
       
        if  self.MNT_tracking == &#34;true&#34;:
            print(&#34;Tracking is ON.&#34;)
            return True 
        else:
            print(&#34;Tracking is OFF.&#34;)
            return False 
        
    def getTrackingRMSError(self):
        &#34;&#34;&#34;
        A function that returns the Root Mean Square (RMS) of the tracking error for both the Alt and Azm motor. 
        
        Args:
            None
        Returns:
            Reply message witht the RMS error
        &#34;&#34;&#34;
        
        self.update()
        print(&#39;The RMS error on the Alt pointing is %.3f arcseconds&#39;%(float(self.MNT_AltRMSErrorArcsec)))
        print(&#39;The RMS error on the Azm pointing is %.3f arcseconds&#39;%(float(self.MNT_AzmRMSErrorArcsec)))

        reply = &#39;The RMS error on the Alt pointing is %.3f arcseconds \n&#39;%(float(self.MNT_AltRMSErrorArcsec))
        reply += &#39;The RMS error on the Azm pointing is %.3f arcseconds&#39;%(float(self.MNT_AzmRMSErrorArcsec))
        return reply

    def getTemps(self):
        &#34;&#34;&#34;
        Prints the temperature of the primary mirror, the ambient temperature, 
        the secondary mirror, the backplate and the M3. 
        The unit of temperature is Celcius.
        
        Returns:
            Message with temperature of the primary mirror, the ambient temperature, 
        the secondary mirror, the backplate and the M3 (in this order)
        &#34;&#34;&#34;
        
        
        self.update()
        Temp_PRI = self.TEMP_pri
        Temp_AMB = self.TEMP_amb
        Temp_SEC = self.TEMP_sec
        Temp_BPL = self.TEMP_backp
        Temp_M3 = self.TEMP_m3
        
        reply = &#34;&#34;
        
        #For the logging
        print(&#34;Temperature of primary:&#34;,Temp_PRI + &#34; C&#34;) 
        print(&#34;Temperature of ambient:&#34;,Temp_AMB + &#34; C&#34;) 
        print(&#34;Temperature of secondary:&#34;,Temp_SEC + &#34; C&#34;) 
        print(&#34;Temperature of backplate:&#34;,Temp_BPL + &#34; C&#34;)
        print(&#34;Temperature of M3:&#34;,Temp_M3 + &#34; C&#34;) 
        
        #for the client
        reply += &#34;Temperature of primary: %s C \n&#34;%(Temp_PRI)
        reply += &#34;Temperature of ambient: %s C\n&#34;%(Temp_AMB)
        reply += &#34;Temperature of secondary: %s C\n&#34;%(Temp_SEC)
        reply += &#34;Temperature of backplate: %s C\n&#34;%(Temp_BPL)
        reply += &#34;Temperature of M3: %s C\n&#34;%(Temp_M3)
        
        return reply


    def MoveFocuserPos(self,position):
        &#34;&#34;&#34;
        A function that moves the focuser position. The position is given 
        is units of microns. 
        Moving the focuser to 10300 microns would be as:
            MoveFocuserPos(10300) 
        
        
        Args: 
            The new position of the focuser given in microns
            
            
        Returns:
            True when finished moving 
            False if timeout occurs
            False if the end position does not match the target position within 5 microns of the target position
        &#34;&#34;&#34;
        self.update()

        #Checks wheter the wanted position is already the current position. DOES NOT WORK FOR SOME REASON???
        if &#34;%s&#34;%(position) == self.FOC_pos:
            print(&#39;The new requested position is already the current position of the focuser. Nothing will happen.&#39;)
            return True

        if position &lt; 0:
            print(&#39;The position is less than 0 microns. The movement will NOT be executed&#39;)
            return False

        #Sends command to change position of focuser
        cmd=requests.get(self.link+&#34;focuser/goto?target=%i&#34;%(position))
        time.sleep(3)
        self.update()
        print(&#39;Starting to move focuser&#39;)
        timeout_sec = 30 #Number of seconds before a timeout
        timeout = time.time() + timeout_sec #setting timeout
        while self.FOC_moving == &#34;false&#34;:
            print(&#39;Focuser moving, now at %s microns&#39;%(self.FOC_pos))
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;A timeout of %i seconds occured.&#39;%(timeout_sec))
                return str(&#34;Error&#34;)
        self.update()
        if abs(self.FOC_pos - position) &lt; 5:  #Checks if the new position is close enough to target. Set to 5 microns initially.
            print(&#39;The focuser has stopped at: %s microns&#39;%(self.FOC_pos))
            return True
        else: 
            print(&#39;The focuser did not reach the target. The current position is %s microns&#39;%(self.FOC_pos))
            return False
       
        
    def ConnectFOC(self):
        &#34;&#34;&#34;
        A function to connect PWI to the focuser. 
        Please note that the rotator is also connected with the focuser
        since they share the same port to PWI. 

        Args:
            None
        
        Returns:
            True if connection is complete
            False if timeout occurs
        &#34;&#34;&#34;
        FOC = requests.get(self.link+&#34;focuser/enable&#34;)
        print(&#39;Trying to connect focuser - please wait&#39;)
        self.update()
        timeout_sec = 10 #Set the number of seconds before timeout.
        timeout = time.time() + timeout_sec
        while self.FOC_connection == &#34;false&#34;:
            print(&#39;Waiting for focuser to connect&#39;)
            self.update()
            time.sleep(1)
            if time.time() &gt; timeout:
                print(&#39;A timeout of %i sec has occured.&#39;%(timeout_sec))
                return False #stop if the timeout is reached!
        return True

    def DisconnectFOC(self):
        &#34;&#34;&#34;
        A function that disconnects the focuser from PWI. 
        Please note that the focuser and rotator are connected to PWI 
        via the same connection. A disconnect of the focuser would therefor
        also disconnect the rotator.
        
        Returns:
            True for finished disconnection
            False for timeout
        &#34;&#34;&#34;
        self.update()
        if self.FOC_connection == &#34;false&#34;:
            print(&#39;The focuser is already disconnected&#39;)
            return True

        cmd = requests.get(self.link+&#34;focuser/disable&#34;)
        self.update()
        timeout_sec = 20
        timeout = time.time() + timeout_sec
        while self.FOC_connection == &#34;true&#34;:
            print(&#39;Trying to disconnect focuser&#39;)
            self.update()
            time.sleep(1)
            if time.time() &gt; timeout:
                print(&#39;A timeout of %i has occured.&#39;%timeout_sec)
                print(&#39;There was error disconnecting the focuser&#39;)
                return False
        return True
    
    # def MoveFocuserInc(self,increment):
    #     &#34;&#34;&#34;
    #     A function that moves the focuser in increments of microns. 
    #     The increments work with addition, i.e. moving the focuser 100 microns and then 
    #     move it again 200 microns results in the focuser moving a total of 300 microns.
        
    #     Example:
    #         The current position is 10000 microns.
    #         You want to move the focuser a further away. 
    #         MoveFocuserInc(100) would then move the focuser 100 microns to 10100 microns.
            
        
    #     Args:
    #         Increment to move focuser in the units of microns
            
    #     Returns:
    #         True when done with moving
    #         False if there is a timeout
    #         False if new target position is less than 0 microns.
    #         False if the new position is more than 5 microns from the target position. 
    #     &#34;&#34;&#34;
    #     self.update()
        
    #     self.FocInc_target = self.FOC_pos + increment

    #     if self.FocInc_target &lt; 0:
    #         print(&#39;The new target is less than 0 microns. The movement will NOT be executed&#39;)
    #         return False
    #     cmd = requests.get(self.link+&#34;?&amp;device=focuser&amp;cmd=move&amp;increment=%i&#34;%(increment))
    #     print(&#39;Offsetting the focuser by %i microns&#39; %(increment))
    #     timeout_sec = 25 #number of seconds before timeout
    #     timeout = time.time() + timeout_sec
    #     time.sleep(3)
    #     self.update()
    #     while self.FOC_moving == &#34;true&#34; and self.FOC_complete == &#39;false&#39;:
    #         print(&#39;Focuser moving, now at %s microns&#39;%(self.FOC_pos))
    #         time.sleep(2)
    #         self.update()
    #         if time.time() &gt; timeout:
    #             print(&#39;A timeout of %i seconds occured.&#39;%(timeout_sec))
    #             return False
    #     self.update()
    #     if abs(self.FOC_pos - self.FocInc_target) &lt; 5: #checks that the new position is within 5 micron of the target. 
    #         print(&#39;Focuser set at position: %s&#39;%(self.Foc_pos))
    #         return True
    #     else:
    #         print(&#39;The focuser did not reach STOPthe target position. The current position is %s microns&#39;%(self.Foc_pos))
    #         return False
    
    
    
    def FocSTOP(self):
        &#34;&#34;&#34;
        Stopping the focuser&#39;s movement. 
        This functions works, along with the other stop-functions, on a separate thread. 
        This ensures the function can always be called, by another terminal with the client running, even if another function is currently being executed. 
        
        Returns:
            True when focuser has been stopped
            False when a timeout occurs
        &#34;&#34;&#34;
        print(&#39;Stopping the focuser - please wait&#39;)
        cmd = requests.get(self.link+&#34;focuser/stop&#34;)
        timeout_sec = 20 #number of seconds before timeout
        timeout = time.time() + timeout_sec
        time.sleep(3)
        self.update()
        while self.FOC_moving == &#34;true&#34;:
            print(&#39;Focuser is still moving, now at %s microns, please wait&#39;%(self.FOC_pos))
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;A timeout of %i seconds occured.&#39;%(timeout_sec))
                return False
        print(&#34;The focuser has now stopped, at %s microns&#34;%(self.FOC_pos))
        return True
    
    
        
    # def FocFindHome(self):
    #     &#34;&#34;&#34;
    #     A function that homes the focuser. The homing-procedure moves the focuser from the current position to 0 microns, 
    #     then stops and then move the focuser to 1000 microns. This procedure takes on the order of 1-2 minutes
    #     depending on the initial starting position. 
        
    #     Returns:
    #         True when the homing procedure is finished
    #         False if there is a timeout. 
    #     &#34;&#34;&#34;
    #     print(&#39;Homing - please wait&#39;)
    #     print(&#39;The position of the focuser before moving is %s microns&#39;%(self.FOC_pos))
    #     cmd = requests.get(self.link+&#34;?&amp;device=focuser&amp;cmd=findhome&#34;)
    #     timeout_sec = 120 #nuber of seconds before timeoutting
    #     timeout = time.time() + timeout_sec
    #     time.sleep(2)
    #     self.update()
    #     while self.FOC_homing == &#34;true&#34; and self.FOC_moving == &#34;true&#34;:
    #         print(&#39;The focuser is homing, currently at %s microns - please wait&#39; %(self.FOC_pos))
    #         self.update()
    #         time.sleep(2)
    #         if time.time() &gt; timeout:
    #             print(&#39;There has been a timeout of %i seconds.&#39;%(timeout_sec))
    #             return False
            
    #     print(&#39;The focuser has finished homing and is at %s microns&#39; %(self.FOC_pos))
    #     print(&#39;\n The focuser will now move to 1000 microns. \n&#39;)
    #     time.sleep(2)
    #     self.update()
    #     while self.FOC_moving == &#34;true&#34;:
    #         print(&#39;The focuser is moving and is currently at %s microns - please wait&#39;%(self.FOC_pos))
    #         self.update()
    #         time.sleep(2)
    #         if time.time() &gt; timeout+60:
    #             print(&#39;There has been a timeout of %i seconds&#39;%(60+timeout_sec))
    #             return False
    #     print(&#39;The focuser has stopped moving and is positioned at %s&#39;%(self.FOC_pos))
    #     return True
        
    
    
    #     #This function starts the focuser&#39;s auto-focusing function. 
    #     #However this does not work, since the function needs MAXIM-DL in PWI4
    # def FocAutofocus(self):
    #     print(&#39;The focuser will start autofocusing - please wait&#39;)
        
    #     cmd = requests.get(self.link+&#34;?&amp;device=focuser&amp;cmd=startautofocus&#34;)
    
    #     return
            
        

    def ConnectMNT(self):
        &#34;&#34;&#34;
        A function that connects PWI to the mount of the telescope and energizes 
        the motors (effectively turning them on). 
        Once the motors are energized, they CANNOT be moved by hand.  

        Args:
            None
        
        Returns:
            True when connected and motors are energized
            False if there is a timeout
        &#34;&#34;&#34;
        
        self.update()
        if self.MNT_connection == &#34;true&#34; and self.MNT_AzmMotor == &#34;true&#34; and self.MNT_AltMotor == &#34;true&#34;:
            print(&#39;The mount is already connected and energized.&#39;)
            return True
        cmd = requests.get(self.link+&#34;mount/connect&#34;)
        self.update()
        time.sleep(1)
        timeout_sec = 15 #Number of seconds before timeoutting
        timeout = time.time() + timeout_sec
        while self.MNT_connection == &#34;false&#34;:
            print(&#39;Trying to connect mount. Please wait&#39;)
            self.update()
            time.sleep(1)
            if time.time() &gt; timeout:
                print(&#39;The connection timed-out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;Mount is connected. Energizing motors now - please wait&#39;)
        time.sleep(1)
        enableAzm = requests.get(self.link+&#34;mount/enable/axis=0&#34;)
        enableAlt = requests.get(self.link+&#34;mount/enable/axis=1&#34;)
        time.sleep(2)
        self.update()
        #I dont know if I can use the same timeout method here since it is in the same function?
        while self.MNT_AzmMotor == &#34;false&#34; and self.MNT_AltMotor == &#34;false&#34;:
            print(&#39;Energizing motors - please wait&#39;)
            time.sleep(1)
            self.update()
            if time.time() &gt; timeout + 30:
                print(&#39;There was a timeout during the energizing of the motors&#39;)
                return False
        print(&#39;Motors are energized! You can proceed.&#39;)
        return True


    def DisconnectMNT(self):
        &#34;&#34;&#34;
        A function that disconnects the mount from PWI.
        The opposite function - &#34;ConnectMNT()&#34; - connects the mount to PWI4.
        
        Returns:
            True when disconnection is finished
            False if there is a timeout before disconnecting
        &#34;&#34;&#34;
        self.update()
        if self.MNT_connection == &#34;false&#34;:
            print(&#39;The mount is already disconnected&#39;)
            return True
        #disableAzm = requests.get(self.link+&#34;mount/disable?axis=0&#34;)
        #disableAlt = requests.get(self.link+&#34;mount/disable?axis=1&#34;)
        time.sleep(2)
        cmd = requests.get(self.link+&#34;mount/disconnect&#34;)
        self.update()
        time.sleep(2)
        timeout_sec = 15 #set the number of seconds before timeout
        timeout = time.time()+timeout_sec
        while self.MNT_connection == &#34;true&#34;:
            print(&#39;Trying to disconnect mount. Please wait&#39;)
            self.update()
            time.sleep(2)
            if time.time() &gt; timeout:
                print(&#39;A timeout of %i sec has occured.&#39;%(timeout_sec))
                return False #stop if the timeout is reached!
        print(&#39;Mount disconnected!&#39;)
        return True
     
    def MntMotorReset(self):
        &#34;&#34;&#34;
        The function reset the motors. It calls two functions: Firstly the function
        MntMotorDisable and then MntMotorEnable. The first function one de-energizes the motors, 
        while the second function energizes the motors. The mount motors have then been reset.
        
        Returns:
            True when resetting the mount is finished
            False if the resetting does not succed
        
        &#34;&#34;&#34;
        print(&#39;Starting to reset mount motors&#39;)
        try:
            self.MntMotorDisable()
        except Exception as e:
            print(e)
        
        try:
            self.MntMotorEnable()
        except Exception as e:
            print(e)
        self.update()
        
        if self.MNT_AltMotor != &#34;true&#34; and self.MNT_AzmMotor != &#34;true&#34;:
            print(&#39;There was an error in the resetting of the motors&#39;)
            return False
        
        return True


    def checkFormatRaDec(self,RA,DEC):
        &#34;&#34;&#34;
        A function that checks the format of the input which is Right Ascension (RA) 
        and Declination (DEC) of a target. 
        
        
        The correct format for RA will be:
            HH:MM:SS.SS
        
        The correct format for DEC will be:
            DD:MM:SS.SS
        
        It is possible to parse a negative DEC. A correct example would be:
            -15:50:06.50
            
        Args:
            Right Ascension of target, Declination of target
        
        Returns:
            The number of errors in the format
        &#34;&#34;&#34;
        
        #Split up the input into 3 parts, not sure if this is a good idea to manually set it to max 3 parts. We&#39;ll see. 
        RA_hr,RA_mm,RA_ss = RA.split(&#34;:&#34;,2) 
        DEC_deg,DEC_mm,DEC_ss = DEC.split(&#34;:&#34;,2)
        print(RA_hr,RA_mm,RA_ss)
        print(DEC_deg,DEC_mm,DEC_ss)
        format_error = 0
        if len(RA_ss) == 5:
            if (RA_ss)[2] == &#34;:&#34;:
                print(&#39;Input error for RA. There is a &#34;:&#34; between the seconds input.&#39;)
                print(&#39;This should be a &#34;.&#34;&#39;)
                format_error += 1
        if len(DEC_ss) == 4:
            if (DEC_ss)[2] == &#34;:&#34;:
                print(&#39;Input error for DEC. There is a &#34;:&#34; between the seconds input.&#39;)
                print(&#39;This should be a &#34;.&#34;&#39;)
                format_error += 1        
        return format_error
        


    def checkFormatAltAzm(self, Alt,Azm):
        &#34;&#34;&#34;
        A function that checks the format of the inputs which is the Altitude (Alt) 
        and Azimuth (Azm) of a target. 
        
        The unit of the inputs are in degrees.
        
        The functions makes sure that the Alt is above 0 and below 90 degrees and
        the Azm is between 0 degrees and 360 degrees. 
        
        Args:
            Altitude in degrees, Azimuth in degrees
            
        Returns:
            Number of errors in format. If #errors &gt; 0, then there is an issue with the format.
        
        &#34;&#34;&#34;
        
        
        error = 0
        if Alt &gt; 90:
            print(&#39;Error:&#39;)
            print(&#39;Altitude is in degrees and should be below 90 degrees&#39;)
            error += 1
        if Alt &lt; 0: 
            print(&#39;Error:&#39;)
            print(&#39;Altitude is in degrees and should above 0 degrees&#39;)
            error += 1
        if Azm &gt; 360:
            print(&#39;Error:&#39;)
            print(&#39;Azimuth is in degrees and should be below 360 degrees&#39;)
            error += 1
        if Azm &lt; 0:
            print(&#39;Error:&#39;)
            print(&#39;Azimuth is in degrees and should be above 0 degrees&#39;)
            error += 1
        
        return error
    


    def MntMoveRaDecJ2000(self):
        &#34;&#34;&#34;
        A function that starts the observation of a target. The target coordinates
        are passed through the function &#34;setTargetRaDecJ2000(Ra,Dec)&#34;. This means
        that the coordinates are first set with &#34;setTargetRaDecJ2000(Ra,Dec)&#34; and then
        this function is used to move the mount.
        
        The target coordinates are then checked for the format. If there are no errors, 
        the target is then checked if it on the night sky with the Observer at Mount Kent, Queensland Australia .
        
        Per version 0.0.1:
        The minimum elevation, called horizon_limit, above the horizon is set to 16 deg.
        This is set in the config file &#34;PWI4_config.py&#34;
        
        If target is above the minimum elevation, the mount will move to the target and track the target.
        
        The mount will stay on target until otherwise told or until the target moves below the horizon limit.

        Returns:
            True when on target
            False if there is a error in the format of RA or DEC
            False if the target is below the minimum elevation above the horizon
            False if there is a timeout
        &#34;&#34;&#34;
        self.update()
        #Load in the RA and DEC (in epoch J2000) from self
        RA = self.RAJ2000
        DEC = self.DECJ2000
        

        #################################################################################
        #This piece checks the format of the input is correct. The following
        #formats are accepted: HH:MM:SS.SS         
        format_err = self.checkFormatRaDec(RA,DEC)        
        if format_err != 0:
            print(&#34;Errors in input format. Tracking will NOT be started&#34;)
            return False
        
        
        ##################################################################################
        
        ##################################################################################
        #Now that the format is checked, the RA and DEC is sent to song_star_checker_AUTOTUNE.py (SSCA)
        #The SSCA script uses the ephem package to where on the sky the star is. 
        #The script then checks whether the coordinates are then correct. 
        # If they are correct, RA and DEC are then sent to SSCA to get the alt,azm
        # If alt is above horizon-limit, then it will proceed to track that target
        
        check = SSCA.coordinates.coordinate_check(self,RA,DEC)
        horizon_limit = conf.NOVO_lower_limit #the alt-limit in degrees for the telescope to track
        ###### PLEASE NOTE THAT PWI WILL TRACK THE TARGET TO THE LIMIT SET IN PWI4 (LOWER TRACKING LIMIT) 
        #I have now set it to 15 deg both here and in PWI, but if we want to change it in the future, we need to change it both places.
        if check == 0:
            star_init = SSCA.star_pos.__init__(self,site=conf.site) #sets the site for Mt. Kent
            star_alt = SSCA.star_pos.star_alt(self,RA,DEC) #uses the SSCA script to get alt
            star_azm = SSCA.star_pos.star_az(self,RA,DEC) #uses the SSCA script to get azm
            #print(&#39;Star alt, star azm&#39;)
            #print(star_alt,star_azm)
            if (str(star_alt)[1:2]) == &#39;:&#39;: #The return value of the altitude of the star, when the Alt is below 10, is i.e. 8 and not 08. The code crashed beforehand due to &#34;8:&#34; not being an integer
                if int(str(star_alt)[0:1]) &gt; horizon_limit:
                    Ra_dec = RAconverter_HHtoDec(RA)
                    Dec_dec = HMS2deg(ra = &#34;&#34;,dec =&#34;%s&#34;%(DEC))
                    print(&#39;The target is above the horizon-limit of %i deg. The tracking will begin momentarily.&#39;%(horizon_limit))
                    track = requests.get(self.link+&#34;mount/gotoradecj2000?ra_hours=%.4f&amp;dec_degs=%.5f&#34;%(float(Ra_dec[0]),float(Dec_dec)))
                    print(track)
                    timeout_sec = 60 #number of seconds before timeout
                    timeout = time.time() + timeout_sec
                    time.sleep(3)   
                    self.update()
                    while self.MNT_slewing == &#34;true&#34;:
                        print(&#39;Not on target yet, please wait&#39;) 
                        time.sleep(2)                   
                        self.update()
                        if time.time() &gt; timeout:
                            print(&#39;A timeout of %i seconds has occured&#39;%(timeout_sec))
                            return False
                    print(&#39;The telescope is on target&#39;)
                elif int(str(star_alt)[0:1]) &lt; horizon_limit:
                    print(&#39;The target is below the horizon-limit of %i deg&#39;%(horizon_limit))
                    print(&#39;The tracking will NOT be started.&#39;)
                    return False
                
                
            elif (str(star_alt)[2:3]) == &#39;:&#39;:    
                if int(str(star_alt)[0:2]) &gt; horizon_limit:
                    Ra_dec = RAconverter_HHtoDec(RA)
                    Dec_dec = HMS2deg(ra = &#34;&#34;,dec =&#34;%s&#34;%(DEC))
                    print(&#39;The target is above the horizon-limit of %i deg. The tracking will begin momentarily.&#39;%(horizon_limit))
                    track = requests.get(self.link+&#34;mount/goto_ra_dec_j2000?ra_hours=%.4f&amp;dec_degs=%.5f&#34;%(float(Ra_dec[0]),float(Dec_dec)))
                    timeout_sec = 60 #number of seconds before timeout
                    timeout = time.time() + timeout_sec
                    time.sleep(3)   
                    self.update()
                    while self.MNT_slewing == &#34;true&#34;:
                        print(&#39;Not on target yet, please wait&#39;) 
                        time.sleep(2)                   
                        self.update()
                        if time.time() &gt; timeout:
                            print(&#39;A timeout of %i seconds has occured&#39;%(timeout_sec))
                            return False
                    print(&#39;The telescope is on target&#39;)
                elif int(str(star_alt)[0:2]) &lt; horizon_limit:
                    print(&#39;The target is below the horizon-limit of %i deg&#39;%(horizon_limit))
                    print(&#39;The tracking will NOT be started.&#39;)
                    return False
        return True
 


    def stopTracking(self):
        &#34;&#34;&#34;
        A function that stops the mount tracking a target. 
        The opposite function - &#34;startTracking()&#34; - starts the tracking.
        
        Returns:
            True when tracking has stopped
            True if the mount has already stopped
            False if there is a timeout
            False if there is an unknown error
            
        
        &#34;&#34;&#34;
        #self.update()
        #if self.MNT_tracking == &#34;false&#34;:
        #    print(&#39;The mount has already stopped tracking&#39;)
        #    return True


        stop = requests.get(self.link+&#34;mount/tracking_off&#34;)
        print(&#39;Stopping tracking request sent - please wait&#39;)
        self.update()
        timeout_sec = 20 #number of seconds before timeout
        timeout = time.time()+timeout_sec
        while self.MNT_tracking == &#34;true&#34;:
            print(&#39;Trying to stop tracking - please wait&#39;)
            time.sleep(1)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;This session has timed-out after %i seconds&#39; %timeout_sec)
                return False
        if self.MNT_tracking == &#34;false&#34;:
            print(&#39;The tracking is OFF and the mount has stoppped.&#39;)
            time.sleep(3)
            self.update()
            print(&#39;The current position of the telescope is %g\xb0 %g\xb0 (Alt,Azm)&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
        else: 
            print(&#39;Something went wrong trying to stop the tracking&#39;)
            return False
        return True

    def parkMount(self):
        &#34;&#34;&#34;
        A function that parks the mount to a parking position. The mount moves to the 
        parking position, tracks the position of the parking position for a very short amount of time
        and then stops tracking the parking position, thereby stopping the mount at the parking position.

        The parking position is set in the PW4_config.py file.
        
        The function uses the function &#34;stopTracking&#34; for stopping the tracking once the mount is on target.

        Args:
            None
        
        Returns:
            True when parking the mount is done 
            False if there was a timeout 
        &#34;&#34;&#34;
        park_alt = conf.park_alt # the altitude in deg where the telescope will be parked 
        park_azm = conf.park_azm # the azimuth in deg where the telescope will be parked
        print(&#39;The mount will be parked to the position %i\xb0, %i\xb0 (Alt,Azm)&#39;%(park_alt,park_azm))
        park = requests.get(self.link+&#34;mount/goto_alt_az?alt_degs=%s&amp;az_degs=%s&#34;%(park_alt,park_azm))
        timeout_sec = 60 #number of sec before timeout
        timeout = time.time() + timeout_sec
        time.sleep(3)
        self.update()
        while self.MNT_slewing == &#34;true&#34;:
            print(&#39;Mount still moving - please wait&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed out after %i seconds&#39; %(timeout_sec))
                return False
        time.sleep(2)
        self.stopTracking() #Stops the tracking of the parking point
        
        return True
        
   
    def MountSTOP(self):
        &#34;&#34;&#34;
        This function stops all mount movements when sent to PWI. 
        Please note that this function is called by the daemon on a different server (server2)
        to make sure this stop function can be called even if other functions are running.
        
        Example: The mount is moving to a new target, but needs to be stopped.
        The &#34;MountSTOP&#34; command is sent, uses server2, which only checks for stop-functions, 
        and stops the mount.
        
        Args:
            None

        Returns:
            True when the mount is stopped
            False if there is a timeout
        &#34;&#34;&#34;
        if self.MNT_tracking == &#39;false&#39;:
            print(&#39;Tracking is already off. The stop command will still be executed!&#39;)
            #A good idea? Otherwise, if there is something wrong and you can&#39;t stop the mount because of the if-statement.

        cmd = requests.get(self.link+&#39;mount/stop&#39;)
        timeout_sec = 15 #Number of seconds before timeout
        timeout = time.time()+timeout_sec
        while self.MNT_slewing == &#34;true&#34; and self.MNT_tracking == &#34;true&#34;:
            print(&#39;Waiting for mount to stop - please wait&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed-out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The mount has stopped&#39;)
        return True

    def MntMotorEnable(self):
        &#34;&#34;&#34;
        A function that energizes the mount motors (Alt and Azm). 
        Essentially turning the motors on.
        Once the motors are energized, they CANNOT be moved by hand.

        Args: 
            None
        
        Returns:
            True when the motors are energized
            False if there is a timeout
        &#34;&#34;&#34;
        print(&#34;Sending command to energize motors - please wait&#34;)
        cmdAzm = requests.get(self.link+&#34;mount/enable?axis=0&#34;)
        cmdAlt = requests.get(self.link+&#34;mount/enable?axis=1&#34;)
        time.sleep(1)
        self.update()
        timeout_sec = 10 #number of seconds before timing out
        timeout = time.time() + timeout_sec
        while self.MNT_AltMotor == &#34;false&#34; and self.MNT_AzmMotor == &#34;false&#34;:
            self.update()
            print(&#39;Waiting for motors to energize - please wait&#39;)
            time.sleep(2)
            if time.time() &gt; timeout:
                print(&#34;The session has timed out after %i seconds&#34;%(timeout_sec))
                return False
        print(&#39;The motors have energized.&#39;)
        return True
        
    def MntMotorDisable(self):
        &#34;&#34;&#34;
        A function that de-energizes the mount motors (Alt and Azm).
        Essentially turning the motors off. 
        Once the motors are de-energized, you&#39;ll be able to move the mount by hand - but please be careful in doing so. 
        
        Args:  
            None

        Returns: 
            True when the motors are disabled
            False if there is a timeout
        &#34;&#34;&#34;
        print(&#39;Sending command to de-energize motors - please wait&#39;)
        cmdAzm = requests.get(self.link+&#34;mount/disable?axis=0&#34;)
        cmdAlt = requests.get(self.link+&#34;mount/disable?axis=1&#34;)
        time.sleep(1)
        self.update()
        timeout_sec = 10 #number of seconds before timeout
        timeout = time.time() + timeout_sec
        while self.MNT_AltMotor == &#34;true&#34; and self.MNT_AzmMotor == &#34;true&#34;:
            print(&#34;Trying to energize motors - please wait&#34;)
            time.sleep(1)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The motors have been disabled.&#39;)
        return True
        
    # def MntMoveIncRaDec(self,RA,DEC):
    #     &#34;&#34;&#34;
    #     A function that moves the mount in increments given by the user, for 
    #     the movement in the Right Ascension and Declination (RA, DEC). 
        
    #     The increments add i.e. an increment of (5,10) and afterwards a new increment
    #     of (10,10) would result in a total movement of (15,20) in RA/Dec respectively.
        
    #     *PLEASE NOTE*: The inputs for RA and DEC increments are in arcseconds. 
        
    #     Args: 
    #         Increments in arcseconds for Right Ascension and Declination
    #     Returns:
    #         True when movement is done and the mount is on target and tracking.
    #         False if there is a timeout.
    #     &#34;&#34;&#34;
        
        
    #     print(&#39;Moving the mount %i arcsec, %i arcsec (Ra,Dec) - please wait&#39;%(RA,DEC))
    #     cmd = requests.get(self.link+&#34;?&amp;device=mount&amp;cmd=move&amp;incrementra=%.8f&amp;incrementdec=%.8f&#34;%(RA,DEC))
    #     timeout_sec = 15 #number of seconds before timing out. 
    #     timeout = time.time() + timeout_sec
    #     time.sleep(2)
    #     self.update()
    #     while self.MNT_on_target == &#34;False&#34;:
    #         print(&#39;Still moving mount - please wait&#39;)
    #         time.sleep(1)
    #         self.update()
    #         if time.time() &gt; timeout:
    #             print(&#39;The session timed out after %i seconds&#39;%(timeout_sec))
    #             return False
    #     print(&#39;The movement is done. The telescope is now tracking.&#39;)
    #     return True
        
    
    # def MntMoveIncAltAzm(self,Alt,Azm):
    #     &#34;&#34;&#34;
    #     A function that moves the mount in increments in Altitude and Azimuth (Alt,Azm).
    #     The increments are given by the user with the unit of *arcseconds*. 
        
    #     It should be noted that the increments add meaning if you add (50,20) and 
    #     then add another (10,10), the total movement will be (60,30) in Alt and Azm respectively.
        
    #     Args:
    #         Increments to move the mount in Altitude and Azimuth in the units of arcseconds
            
    #     Returns:
    #        True when movement in done and mount is on target and tracking
    #        False if there is a timeout.
    #     &#34;&#34;&#34;
        
    #     print(&#39;Moving the mount - please wait&#39;)
    #     cmd = requests.get(self.link+&#34;?&amp;device=mount&amp;cmd=move&amp;incrementazm=%.4f&amp;incrementalt=%.4f&#34;%(Azm,Alt))
    #     time.sleep(2)
    #     timeout_sec = 15 #number of seconds before timing out
    #     timeout = time.time() + timeout_sec
    #     while self.MNT_on_target == &#34;False&#34;:
    #         print(&#39;Mount still moving - please wait&#39;)
    #         time.sleep(1)
    #         self.update()
    #         if time.time() &gt; timeout:
    #             print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
    #             return False
    #     print(&#39;The movement is done. The tracking is on.&#39;)
    #     return True
    
    

    def MntMoveRaDec(self):
        &#34;&#34;&#34;
        A function that moves the mount to the Right Ascension and Declination (RA and DEC). 
        The input is loaded in from the function &#34;setTargetRaDec(Ra,Dec)&#34; where the target
        coordinates are set. This means you first set the target coordinates with 
        &#34;setTargetRaDec(Ra,Dec)&#34; and then move the mount with this function.

        Args:
            None
            
        Returns:
            True when the movement is finished and the mount is on target and tracking
            False if there is a timeout
            False if there is an error in the format of the input
            False if the target is below horizon limit - which is set in the PWI4_config file
        &#34;&#34;&#34;
        
        self.update()
        RA = self.RA
        DEC = self.DEC

        print(RA,DEC)
        
        print(&#39;Moving mount - please wait&#39;)
        check = self.checkFormatRaDec(RA,DEC)
        if check != 0:
            print(&#39;Error&#39;)
            print(&#39;There is an error in the format of the RA/DEC. Tracking will NOT be started.&#39;)
            return False
        
        star_init = SSCA.star_pos.__init__(self,site=conf.site)
        star_alt = SSCA.star_pos.star_alt(self,RA,DEC)
        star_azm = SSCA.star_pos.star_az(self,RA,DEC)
        horizon_limit = conf.NOVO_lower_limit #tracking limit. 
        alt_degree,_,_ = str(star_alt).split(&#34;:&#34;)
        print(alt_degree)
        
        if int(alt_degree) &gt; horizon_limit:
            print(&#39;Target is above horizon limit of %i degrees&#39;%(horizon_limit))
            print(&#39;The tracking will start momentarily - please wait&#39;)
            Ra_dec = RAconverter_HHtoDec(RA)
            Dec_dec = HMS2deg(ra = &#34;&#34;,dec =&#34;%s&#34;%(DEC))
            print(Ra_dec,Dec_dec)
            cmd = requests.get(self.link+&#34;mount/goto_ra_dec_apparent?ra_hours=%.5f&amp;dec_degs=%.5f&#34;%(float(Ra_dec[0]),float(Dec_dec)))
            timeout_sec = 60 #number of seconds before timing out
            timeout = time.time() + timeout_sec
            time.sleep(2)
            self.update()
            while self.MNT_slewing == &#34;true&#34;:
                print(&#39;Mount is still moving to target - please wait&#39;)
                time.sleep(2)
                self.update()
                if time.time() &gt; timeout: 
                    print(&#39;The session has timed out after %i seconds&#39; %(timeout_sec))
                    return False
            print(&#39;The telescope is on target and is tracking&#39;)
        
        elif int(alt_degree) &lt; horizon_limit: 
            print(&#39;The target is below the horizon limit of %i degrees&#39;%(horizon_limit))
            print(&#39;Tracking will NOT be started!&#39;)
            return False

        return True

        
    def MntMoveAltAzm(self):
        &#34;&#34;&#34;
        A function to move to the mount to an Altitude and Azimuth which is 
        first set with the function &#34;setTargetAltAzm(Alt,Azm)&#34;. This means
        you have to first set the Alt/Azm coordinates with &#34;setTargetAltAzm(Alt,Azm)&#34;
        and then use this function to move the mount.
        
        The input is first checked for format errors and if there are no errors,
        and the target altitude is above the horizon limit - which is set to 15 degrees above horizon per version 0.0.1 -
        gives the commmand to move the mount to the given coordinates. 

        Args:
            None
        
        Returns:
            True when the mount has finished the movement and is on target and tracking
            False if there is an error in the format of the input
            False if the target is below the horizon limit 
        &#34;&#34;&#34;
        self.update()
        #Loading in the altitude and azimuth
        Alt = self.Alt
        Azm = self.Azm
        
        #check function for Alt/azm
        errors = self.checkFormatAltAzm(Alt,Azm)
        if errors != 0:
            print(&#39;There was an error with the Alt/Azm format&#39;)
            print(&#39;The movement will NOT begin&#39;)
            return False
        horizon_limit = conf.NOVO_lower_limit #degrees above the horizon where the telescope cannot track below. SHOULD BE CHANGE ALSO IN PWI4 and in MntMoveRaDec and MntMoveRaDecJ2000
#        if Alt &gt; 90:
#            print(&#39;The altitude must be lower than 90 deg. The mount will NOT be moved&#39;)
#            return False
        if Alt &lt; horizon_limit:
            print(&#39;The altitude must be higher than %i degrees. The mount will NOT be moved&#39;%(horizon_limit))
            return False

        
        print(&#39;Starting movement in a moment - please wait&#39;)
        print(&#39;Starting position is at %.4f\xb0 %.4f\xb0 (Alt/Azm)&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
        cmd = requests.get(self.link+&#34;mount/goto_alt_az?alt_degs=%s&amp;az_degs=%s&#34;%(Alt,Azm))
        timeout_sec = 60 #number of seconds before timing out.
        timeout = time.time() + timeout_sec
        time.sleep(2)
        self.update()
        while self.MNT_slewing == &#34;true&#34;:
            print(&#39;Still moving the mount - please wait&#39;)
            self.update()
            time.sleep(2)
            if time.time() &gt; timeout:
                print(&#39;This session has timedout after %i seconds&#39;%(timeout_sec))
                print(&#39;The position at timeout was Alt: %s and Azm: %s&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
                return False
        print(&#39;The mount is on target and is tracking at %.3f\xb0,%.3f\xb0 (Alt/Azm)&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
        return True
        
    def startTracking(self):
        &#34;&#34;&#34;
        A function that starts the tracking. The mount will track the current position of the telescope/mount.
        
        Args:
            None
        
        Returns:
            True when tracking is on
            False if there is a timeout
        &#34;&#34;&#34;
        print(&#39;Starting tracking - please wait&#39;)
        
        cmd = requests.get(self.link+&#34;mount/tracking_on&#34;)
        
        timeout_sec = 15 # number of seconds before timing out
        timeout = time.time() + timeout_sec
        time.sleep(1)
        self.update()
        while self.MNT_tracking == &#34;False&#34;:
            print(&#39;Not tracking yet - please wait&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout: 
                print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;Tracking is now on&#39;)
        return True
        
    
    def LoadPointingModel(self,filename):
        &#34;&#34;&#34;
        This function loads in a pointing model from Documents/PlaneWave Instruments/PWI4/Mount/
        The filename has some restrictions:
            1. only alphanumeric characters, underscore and hyphen
            2. must end in &#34;.pxp&#34;
            3. Must be in the path &#34;Documents/PlaneWave Instruments/PWI4/Mount&#34; on the computer
        Example of command:
            LoadPointingModel(&#39;Model1.pxp&#39;)
            
        Args:
            Filename of pointing model you want to import
        Returns:
            True when pointing model is loaded
            False if name of new pointing model does not correspond to the filename           
        &#34;&#34;&#34;
        
        
        name, filetype = filename.split(&#39;.&#39;)
        if filetype != &#34;pxp&#34;:
            print(&#39;Error&#39;)
            print(&#39;The filetype must be .pxp!&#39;)
            return
        cmd = requests.get(self.link+&#34;mount/model/load?filename=%s&#34;%(filename))
        time.sleep(2)
        self.update()
        if self.MNT_PointingModel == filename:
            print(&#39;The poiting model %s has been loaded successfully.&#39;%(filename))
            return True
        else:
            print(&#39;There was an error loading in the pointing model.&#39;)
            return False



       
    # def setTrackingRates(self,RArate,DECrate):
    #     &#34;&#34;&#34;
    #     A function that sets the tracking rates, expressed as an offset to the standard sidereal rate. 
    #     If both inputs are 0, the tracking will be at the sidereal rate. 
    #     The units for the RArate and DECrate is arcseconds per sec.
    #     &#34;&#34;&#34;
        
    #     cmd = requests.get(self.link+&#34;?&amp;device=mount&amp;cmd=trackingrates&amp;rarate=%.2f&amp;decrate=%.2f&#34;%(RArate,DECrate))
        
    #     return cmd
        

    #     #NOT DONE YET!


    def checkFormatArcsec(self,Arcsec):
        &#34;&#34;&#34;
        A function that checks the format of arcseconds. 
        Per version 0.0.1, the function simply checks whether the input is above 
        60 or below 0. This may be changed in future versions.
        
        Args:
            Input in arcseconds

        Returns:
            Number of errors in the format  
        &#34;&#34;&#34;
        
        print(&#39;Checking format - please wait&#39;)
        error = 0 #number of errors:
        if float(Arcsec) &gt; 60.0:
            print(&#39;Error:&#39;)
            print(&#39;The number of arc seconds need to be below 60&#39;)
            error += 1
        if float(Arcsec) &lt; 0.0:
            print(&#39;Error:&#39;)
            print(&#39;The number of arc seconds should be above 0&#39;)
            error +=1
        return error


    def startMntHoming(self):
        &#34;&#34;&#34;
        A function that starts the homing procedure in PWI4 for the mount. 
        *PLEASE NOTE*: Per version 0.0.1 this function crashes the simulator and
        has not been tested on a real telescope. It is therefor suggested to be very careful when
        using this function

        Args:
            None
        
        Returns:
            Per version 0.0.1: Nothing.
        &#34;&#34;&#34;

        self.update()
        print(&#39;Starting homing of the mount - please wait&#39;)
        cmd = requests.get(self.link+&#39;mount/find_home&#39;)
        return cmd


    def AddPointToModel(self,RA,DEC):
        &#34;&#34;&#34;
        A function that adds a point/target to current pointing model. It assigns the current telescope position (RA,DEC) to the input provided by 
        the user - which is also a RA and DEC in J2000 epoch. The input is checked for format errors before adding point to pointing model.
        The telescope start tracking when this command is executed.
        
        Example of command:
            AddPointToModel(&#34;04:35:55.33&#34;,&#34;16:30:29.5&#34;) #Aldebaran&#39;s J2000.0 coordinates.

        Args:
            RA and DEC in J2000 epoch to add to the current pointing model

        Returns:
            True when point is added to the pointing model
            False if there is a format error in the input
            False if there is a timeout
        &#34;&#34;&#34;
        
        
        print(&#39;Adding point to model - please wait&#39;)
        check = self.checkFormatRaDec(RA,DEC)
        if check != 0:
            print(&#39;There was an error in the format of RA/DEC&#39;)
            print(&#39;No point will be added to the pointing model&#39;)
            return False

        cmd = requests.get(self.link+&#34;mount/model/add_point?ra_j2000_hours=%s&amp;dec_j2000_degs=%s&#34;%(RA.replace(&#34;:&#34;,&#34;%20&#34;),DEC.replace(&#34;:&#34;,&#34;%20&#34;)))
        timeout_sec = 30 #number of seconds before timing out the session. 
        timeout = time.time() + timeout_sec
        time.sleep(1)
        self.update()
        while self.MNT_slewing == &#34;true&#34;:
            print(&#39;Not on target yet - please wait&#39;)
            time.sleep(1)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The point at %s, %s (RA,DEC) has been added to the current pointing model&#39;%(RA,DEC))
        self.update()
        print(&#39;There are now %s points in the pointing model&#39;%(self.MNT_PointingModelPoints))
        return True
    

    
      
    def SavePointingModel(self,filename):
        &#34;&#34;&#34;
        The function saves the current pointing model, using the name provided by the user. 
        The pointing model is saved in &#34;Docuements/PlaneWave Instruments/PWI4/Mount&#34; on the local computer.
        The filename must be alphanumeric, but can also contain hyphen, &#34;-&#34;, and underscore &#34;_&#34;.
        The filename must end in &#34;.pxp&#34;.

    
        Example of command: 
            SavePointingModel(&#34;Feb_model.pxp&#34;)
        
        Args:
            The filename under which the pointing model is saved
        Returns:
            True when the pointing model is saved
            False if the filename is not alphanumeric
        &#34;&#34;&#34;
        #Test for ending
        try:
            pxp = filename.split(&#34;.&#34;)
            if pxp[1] != &#34;pxp&#34;:
                print(&#39;The filename needs to end with .pxp&#39;)
                return False
        except: 
            print(&#39;The filename must contain a &#34;.pxp&#34;&#39;)
            return False

        #testing for alphanumeric name
        copy = pxp[0]
        copy = copy.replace(&#34;-&#34;,&#34;&#34;)
        copy = copy.replace(&#34;_&#34;,&#34;&#34;)
        check = copy.isalnum()

        if check == False:
            print(&#39;Error:&#39;)
            print(&#39;The filename contains other characters than alphanumeric, &#34;-&#34; and &#34;_&#34;.&#39;)
            print(&#39;The model will not be saved.&#39;)
            return False
        
        print(&#39;The pointing model will be saved as %s momentarily - please wait.&#39; %(filename))
        cmd = requests.get(self.link+&#34;mount/model/save?filename=%s&#34;%(filename))
        time.sleep(1)
        self.update()
        time.sleep(1)
        if self.MNT_PointingModel == &#34;%s&#34;%(filename):
            print(&#39;Model saved. Location: Documents/PlaneWave Instruments/PWI4/Mount&#39;)
            return True
        else: 
            print(&#39;The pointing model was not saved correctly&#39;)
            return False
        
      
    
    
    def ClearPointingModel(self):
        &#34;&#34;&#34;
        This function deletes ALL the points in the current pointing model. 
        PLEASE BE CAREFUL WHEN USING THIS!

        Args:
            None

        Returns:
            True when points have been deleted
            False if the timeout session runs out 
        &#34;&#34;&#34;
        self.update()
        cmd = requests.get(self.link+&#34;mount/model/clear_points&#34;)
        self.update()
        time.sleep(1)
        timeout_sec = 10
        timeout = time.time() + timeout_sec
        while self.MNT_PointingModelPoints != &#34;0&#34;:
            print(&#39;Waiting for points to clear&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;This session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The pointing model has been cleared&#39;)
        return True




    def FansON(self):
        &#34;&#34;&#34;
        A function that turns the fans on in the telescope. 
        Firstly checks if the fans are already on. If not, then turns on fans.
        
        Args:
            None

        Returns: 
            True when fans are turned on.
            True if fans are already on.
            False if there is a timeout
        &#34;&#34;&#34;
        self.update()
        if self.FANS_state == &#39;True&#39;:
            print(&#39;The fans are already on&#39;)
            return True
        else:
            cmd = requests.get(self.link+&#39;?&amp;device=fans&amp;cmd=turnon&#39;)
            timeout_sec = 15 #number of seconds before timeout
            timeout = time.time() + timeout_sec
            while self.FANS_state == &#34;False&#34;:
                print(&#39;Waiting for fans to turn on - please wait&#39;)
                time.sleep(3)
                self.update()
                if time.time() &gt; timeout:
                    print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                    return False
        print(&#39;The fans are turned on&#39;)
        return True

    def FansOFF(self):
        &#34;&#34;&#34;
        A function that turns off the fans in the telescope. 
        If the fans are already off, then nothing happens. 
        Are the fans on, then a command is sent to turn the fans off.

        Args:
            None
        
        Returns: 
            True when fans are turned off
            True if fans are already off
            False is there is a timeout
        &#34;&#34;&#34;
        self.update()
        if self.FANS_state == &#39;False&#39;:
            print(&#39;The fans are already off.&#39;)
            return True
        else:
            cmd = requests.get(self.link+&#39;?&amp;device=fans&amp;cmd=turnoff&#39;)
            timeout_sec = 15 #Number of seconds before timeout
            timeout = time.time() + timeout_sec
            while self.FANS_state == &#34;True&#34;:
                print(&#39;Waiting for fans to turn off - please wait&#39;)
                time.sleep(2)
                self.update()
                if time.time() &gt; timeout:
                    print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                    return False
            print(&#39;The fans are turned off&#39;)
            return True
    

    def Rot_Move(self,position):
        &#34;&#34;&#34;
        A function that moves the rotator. The user provides the new position 
        in degrees, between 360 degrees and 0 degrees. 
        
        Args:
            New position to run rotator to. Must be between 0 and 360 degrees.
            
        Returns: 
            True when the rotator has finished moving
            False if the new position is above 360 degrees or below 0 degrees
            False if there is a timeout
        &#34;&#34;&#34;
        if position &gt; 360:
            print(&#39;The new position needs to be below 360 degrees.&#39;)
            return False
        
        if position &lt; 0: 
            print(&#39;The new position needs to be above 0 degrees.&#39;)
            return False
        
        print(&#39;The rotator will start moving momentarily - please wait&#39;)
        
        cmd = requests.get(self.link+&#34;rotator/goto_field?degs=%i&#34;%(position))
        time.sleep(2)
        self.update()
        timeout_sec = 180 #number of seconds before time-outting
        timeout = time.time() + timeout_sec
        while self.ROT_moving == &#34;true&#34;:
            self.update()
            print(&#39;The rotator is moving, current position is %s deg - please wait&#39;%(self.ROT_position))
            time.sleep(5)
            if time.time() &gt; timeout:
                print(&#39;There has been a timeout of %s seconds&#39;%(timeout_sec))
                print(&#39;The rotator position at timeout was %s deg&#39;%(self.ROT_position))
                return False
        print(&#39;The rotator has stopped and is at %s deg&#39;%(self.ROT_position))
        
        return True

        
        
    
    def RotSTOP(self):
        &#34;&#34;&#34;
        A function that stops all rotator movement. 
        This function is set on a separate thread along with the other stop-functions, to ensure they can always be called. 

        Args:
            None

        Returns:
            True when the rotator has stopped
            False if there is a timeout
        &#34;&#34;&#34;
        
        print(&#39;Trying to stop the rotator - please wait&#39;)
        cmd = requests.get(self.link+&#34;rotator/stop&#34;)
        time.sleep(1)
        self.update()
        timeout_sec = 15 #number of seconds before timeout
        timeout = time.time() + timeout_sec
        while self.ROT_moving == &#34;true&#34;:
            print(&#39;The rotator is still moving - please wait&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The rotator has stopped&#39;)
        return True
    
    
    # def Rot_StartHoming(self):
    #     &#34;&#34;&#34;
    #     A function that starts the rotator homing procedure. 
        
    #     Returns:
    #         True when the homing procedure is finished.
    #         False if there is a timeout.
    #     &#34;&#34;&#34;
    #     print(&#39;The rotator will start homing - please wait&#39;)
        
    #     cmd = requests.get(self.link+&#34;?&amp;device=rotator&amp;cmd=findhome&#34;)
        
    #     timeout_sec = 420 #number of seconds, 7 minutes
    #     timeout = time.time() + timeout_sec
    #     time.sleep(2)
    #     self.update()
    #     while self.ROT_homing == &#34;True&#34;:
    #         self.update()
    #         print(&#39;Rotator is homing, currently at %s deg - please wait&#39;%(self.ROT_position))
    #         time.sleep(2)
    #         if time.time() &gt; timeout:
    #             print(&#39;The session has timed out after %i seconds.&#39;%(timeout_sec))
    #             print(&#39;The rotator position at timeout was %s deg&#39;%(self.ROT_position))
    #             return False
    #     time.sleep(5)
    #     self.update()
    #     print(&#39;The rotator has finished homing - current position is %s deg&#39; %(self.ROT_position))
        
    #     return True
    
    def Rot_derotateStart(self):
        &#34;&#34;&#34;
        A function that enables de-rotation on the Alt-Azm mount.
        
        Args:
            None

        Returns:
            True when the de-rotation is enabled
            False if there is a timeout
        &#34;&#34;&#34;
        print(&#39;Enabling Alt-Azm field de-rotation - please wait&#39;)
        cmd = requests.get(self.link+&#34;rotator/enable&#34;)
        timeout_sec = 10 #number of seconds before time-out
        timeout = time.time()+ timeout_sec
        self.update()
        while self.ROT_AltAzDerotate == &#34;False&#34;:
            self.update()
            print(&#39;Derotation not enabled yet - please wait&#39;)
            time.sleep(1)
            if time.time() &gt; timeout:
                print(&#34;The session has timedout after %i seconds&#34;%(timeout_sec))
                return False
        print(&#39;Alt-Azm field de-rotation has been enabled.&#39;)
        return True
    
    
    def Rot_derotateStop(self):
        &#34;&#34;&#34;
        A function that disables de-rotation on the IFR90 focuser and rotator instrument.
        
        Args:
            None

        Returns:
            True when the de-rotation is disabled
            False if there is a timeout
        &#34;&#34;&#34;
        print(&#39;Disabling Alt-Azm field de-rotation - please wait&#39;)
        cmd = requests.get(self.link+&#34;rotator/disable&#34;)
        timeout_sec = 10 #number of seconds before timing out
        timeout = time.time() + timeout_sec
        self.update()
        while self.ROT_AltAzDerotate == &#34;True&#34;:
            print(&#39;Trying to disable Alt-Azm field de-rotation - please wait&#39;)
            self.update()
            time.sleep(1)
            if time.time() &gt; timeout:
                print(&#39;The session timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The Alt-Azm de-rotation has been disabled&#39;)
        return True
    
    def getRotatorDerotate(self):
        &#34;&#34;&#34;
        The function displays the current state of the derotation/field rotator on the IFR90 focuser/rotator unit. 
        
        Args:
            None

        Returns:
            A message of whether the deratote is ON or OFF
            False is there was an error
        &#34;&#34;&#34;
        
        self.update()
        if self.ROT_derotate_enabled == &#34;true&#34;:
            print(&#39;The Alt/Azm derotate is ON&#39;)
            reply = &#34;The Alt/Azm derotate is ON&#34;
            return reply
        
        if self.ROT_derotate_enabled == &#34;false&#34;:
            print(&#39;The Alt/Azm derotate is OFF&#39;)
            reply = &#34;The Alt/Azm deratote is OFF&#34;
            return reply
        else:
            print(&#39;There was an error&#39;)
            return False
            

    def setTargetRaDecJ2000(self,RA,DEC):
        &#34;&#34;&#34;
        A function to set coordinates for target in the J2000 Epoch. 
        The function MntMoveRaDecJ2000() can then take the values from self and 
        move the mount to the target. 
        
        Args:
            Right Ascension and Declination for target in J2000 Epoch in a string.
            Format should be:
                DD:MM:SS.SS
                HH:MM:SS.SS
        
        Example:
            setTargetRaDecJ2000(&#34;04:35:55.33&#34;,&#34;16:30:29.5&#34;,63.45, -188.94) #Aldebaran used for example
        
        Returns:
            True if the coordinates are set in self
            True if the coordinates are already set in self
            False if there was an error setting the coordinates
        &#34;&#34;&#34;
        #Check if the coordinates are already set
        try:
            if self.RAJ2000 == RA or self.DECJ2000 == DEC:
                print(&#39;The new coordinates are already set&#39;)
                return True
        except Exception as e:
            print(e)
    
        
        #save the new coordinates in self
        self.RAJ2000 = RA
        self.DECJ2000 = DEC

        ######################################################### proper motion stuff - can easily be commented out this way. 
        

        # #calculating the proper motion into RA and DEC. 
        # start_date = datetime.datetime(2000,1,1,0,0) #UTC time at the start of J2000.0 epoch
        # end_date = datetime.datetime.utcnow()
        # difference = end_date - start_date #The difference between now and J2000.0 start.
        # difference_yr = (difference.days + difference.seconds/86400.)/365.2425 #The difference in years between now and J2000.0 epoch.

        # #calculating the proper motion into Right Ascension and Declination
        # RA_pm * difference_yr *(1000) #now in arcseconds
        # DEC_pm * difference_yr *(1000) #now in arcseconds

        
        
        # #saves the proper motion in self
        # self.RAJ2000_pm = RA_pm
        # self.DECJ2000_pm = DEC_pm

        # if self.RAJ2000_pm !=RA_pm or self.DECJ2000_pm != DEC_pm:
        #     print(&#39;There was an error setting the proper motion&#39;)
        #     return False
        # ##############################################################

       
        #check if they are set correctly
        if self.RAJ2000 != RA or self.DECJ2000 != DEC:
            print(&#39;There was an error setting RA/DEC&#39;)
            return False
        

        print(&#39;The new coordinates have been set&#39;)
        return True
    
    def setTargetAltAzm(self,Alt,Azm):
        &#34;&#34;&#34;
        A function that sets the target coordinates for the Alt/Azm target.
        This function is used together with MntMoveAltAzm(), where the user
        first sets the coordinates with this function and then moves the 
        telescope with MntMoveAltAzm().
        
        The coordinates are set in self.
        
        Args:
            Altitude and Azimuth of the target as integers.
            
        Returns:
            True if the target coordinates are set correctly
            True if the new coordinates match the coordinates already set in self
            False if there was an issue setting the coordinates
            
        &#34;&#34;&#34;
        self.update()
        #Check if coordinates are already set
        try:
            if self.Alt == Alt and self.Azm == Azm:
                print(&#39;The new coordinates is already set&#39;)
                return True
        except Exception as e:
            print(e)
        
        #Set coordinates in self
        self.Alt = Alt
        self.Azm = Azm
        
        #check if they are corretly set in self
        if self.Alt != Alt or self.Azm != Azm:
            print(&#39;There was an error setting the new coordinates&#39;)
            return False
        
        print(&#39;The new Alt/Azm coordinates have been set&#39;)
        return True
    
    def setTargetRaDec(self,Ra,Dec):
        &#34;&#34;&#34;
        A function that set the coordinates for the target in topocentric 
        coordinates. 
        
        Args:
            Right Ascension and Declination in topocentric coordinates
            
            Format should be:
                DD:MM:SS.SS
                HH:MM:SS.SS
            Example:
                setTargetRaDec(&#34;11:32:59.79&#34;,&#34;-31:51:28.1&#34;)    
                
        Returns:
            True if the coordinates are set correctly
            True if the new coordinates match the existing coordinates
            False if there was an error setting the coordinates
        &#34;&#34;&#34;
        self.update()
        
        try:
            if self.RA == Ra or self.DEC == Dec:
                print(&#39;The new coordinates are already set&#39;)
                return True
        except Exception as e:
            print(e)
        
        self.RA = Ra
        self.DEC = Dec
        
        if self.RA != Ra or self.DEC != Dec:
            print(&#39;There was an error setting the new coordinates&#39;)
            return False
        print(&#39;The new coordinates have been set&#39;)
        return True
        

    
################################################################################

PW = PWI4()
####################### WORKS ##########

#### Functions that are for information

#PW.getALL()
#PW.getRA2000()
#PW.getDEC2000()
#PW.getJD()
#PW.getUTC()
#PW.getMNT_CONNECT()
#PW.getStatus()
#PW.getFocuser_CONNECT()
#PW.getROT_CONNECT()
#PW.getIsTrackingOn()
#PW.getTemps()



##### Function that are for setting a new value or doing something actively

#PW.ConnectMNT()
#PW.DisconnectMNT()
#PW.MountSTOP()
#PW.parkMount()
#PW.MntResetMotors()
#PW.MntMotorEnable()
#PW.MntMotorDisable()



#PW.ConnectFOC()
#PW.DisconnectFOC()
#PW.MoveFocuserPos(10000) #Try-except in update!
#PW.MoveFocInc(50)
#PW.FocFindHome()
#PW.FocSTOP() 



#PW.Rot_Move(170)
#PW.Rot_derotateStart()
#PW.Rot_derotateStop()
#PW.Rot_StartHoming()
#PW.Rot_stop()

#PW.FansON()
#PW.FansOFF()

#PW.stopTracking()
#PW.startTracking()

#PW.setTargetAltAzm(30,30) 
#PW.setTargetRaDec(&#34;&#34;,&#34;&#34;)
#PW.setTargetRaDecJ2000(&#34;&#34;,&#34;&#34;)


#PW.MntMoveRaDecJ2000()) 
#PW.MntMoveRaDEC() 
#PW.MntMoveAltAzm() 
#PW.MntMoveIncRaDec(10,10) 
#PW.MntMoveIncAltAzm(5,5) 

#PW.checkFormatRaDec(&#34;20:25:38.99&#34;,&#34;-56:44:07.7&#34;)
#PW.checkFormatAltAzm(90.0,340)

#PW.LoadPointingModel(&#34;test.pxp&#34;)
#PW.AddPointToModel(&#34;03:47:14.86&#34;,&#34;-74:14:18.9&#34;) #Works but not quite sure what to do with it




################# TESTING AREA / DOESNT WORK (at least the way I want it to work) ########################


#PW.AZM_motor_error() #Needs to give the correct error in words (and number) to the user
#PW.ALT_motor_error() #Needs to give the correct error in words and numbers to the end user

#PW.FocAutofocus()

#PW.MntMoveRaDec(&#34;19:11:00&#34;,&#34;-22:19:05&#34;) #A lot of work needed for this to work, compared to the usage of the function. See entry 8/11/2019 in logbook for more on this.

#PW.LoadPointingModel(&#34;stupid.pxp&#34;) #Needs to be tested with a pointing model file with a while/if loop to check that the pointingmodel has changed.

#PW.setTrackingRates(3,3) #Needs a lot of work, not done at all.
#PW.checkFormatArcsec() #Need some work, not done at all.



#PW.startMntHoming() #Crashes the simulator at search 7 in Azm. Not sure why, but the Azm value in the simulator goes to 240000074 (deg) so something is clearly wrong.

#PW.JogAltAzm(0.001,0) #Crashes the motor by moving very fast. The lowest value that produces a response in PWI is 0.01 deg/s and that crashes the motors (sends the telescope moving very fast
                        #I can&#39;t give it a lower value, or no response from PWI in those cases. So I am not sure what to do with this function. Giving a velocity also seems weird, given 
                        # I don&#39;t give an end-time. So do the function just give it a constant velocity and it will move at that speed until crash? 
                        # That is not how the arrows in PWI work. 
                        
                        
                        
#PW.SyncMountCoorJ2000(&#34;02:50:28.24&#34;,&#34;-75:04:00.9&#34;) #Does not work, crashes with an altitude of -78 deg. 
                        
#PW.SavePointingModel(&#34;Test_hyphen-underscore&#34;) #Not fully working yet, check for alphanumeric (with hyphen and underscore) but does not currently save the pointing model</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PW4.PWI4"><code class="flex name class">
<span>class <span class="ident">PWI4</span></span>
</code></dt>
<dd>
<div class="desc"><p>This function initializes the connection to PWI4.
It also defines names for the variables from PWI4, which are stored in self. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>True</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PWI4():   
    def __init__(self):
        &#34;&#34;&#34;
        This function initializes the connection to PWI4. 
        It also defines names for the variables from PWI4, which are stored in self. 
        
        Args:
            None

        Returns: True
        &#34;&#34;&#34;
        ##this is the IP address of PWI4
        self.link=&#34;http://%s:%i/&#34;%(conf.NOVO_tel_com_ip,conf.NOVO_tel_com_port)
        status = requests.get(self.link+&#34;status&#34;)
    
        
        data = status.text.split(&#39;\n&#39;)
        self.status = status.text
        self.data = data

        #site parameters
        self.site_latitude = data[1].split(&#39;=&#39;)[1] #latitude of position of the telescope
        self.site_longitude = data[2].split(&#39;=&#39;)[1] #longitude of the position of the telescope
        self.site_elevation = data[3].split(&#39;=&#39;)[1] #elevation at position of telescope
        self.site_lmst = data[4].split(&#39;=&#39;)[1] #local mean sidereal time
        
        #Focuser
        self.FOC_connection = data[36].split(&#39;=&#39;)[1]
        self.FOC_pos = data[38].split(&#39;=&#39;)[1]
        self.FOC_moving = data[39].split(&#39;=&#39;)[1]


        #Rotator
        self.ROT_connection = data[40].split(&#39;=&#39;)[1]
        self.ROT_moving = data[44].split(&#39;=&#39;)[1]
        self.ROT_mechanial_pos = data[42].split(&#39;=&#39;)[1]
        self.ROT_pos = data[43].split(&#39;=&#39;)[1]
        self.ROT_derotate_enabled = data[41].split(&#39;=&#39;)[1]

        #Mount
        self.MNT_connection = data[5].split(&#39;=&#39;)[1] #true/false
        self.MNT_slewing = data[15].split(&#39;=&#39;)[1] #True/False
        self.MNT_Alt = data[14].split(&#39;=&#39;)[1] #in deg
        self.MNT_Azm = data[13].split(&#39;=&#39;)[1] #in deg
        self.MNT_Ra2000 = data[9].split(&#39;=&#39;)[1] #in hours
        self.MNT_Dec2000 = data[10].split(&#39;=&#39;)[1] #in degrees
        self.MNT_tracking = data[16].split(&#39;=&#39;)[1] #true/false
        self.MNT_AltMotor = data[27].split(&#39;=&#39;)[1] #enabled/disabled given by True/False
        self.MNT_AzmMotor = data[22].split(&#39;=&#39;)[1] #enabled/Disabled given by True/False
        self.MNT_PointingModel = data[32].split(&#39;=&#39;)[1] #filename of current pointing model
        self.MNT_PointingModelPoints = data[33].split(&#39;=&#39;)[1] #Number of points in pointing model
        self.MNT_PointingModelError = data[35].split(&#39;=&#39;)[1] #Error of pointing model in arcsec
        self.MNT_AltRMSErrorArcsec = data[23].split(&#39;=&#39;)[1] #Error on pointing in Arcsec on the altitude motor
        self.MNT_AzmRMSErrorArcsec = data[28].split(&#39;=&#39;)[1] #Error on pointing in Arcsec on the azimuth motor
        



        #Setting the different values with a &#34;human-readable&#34; naming-scheme.

        #Status (times)
    #     self.STAT_utc = self.tree[0][0].text
    #     self.STAT_lst = self.tree[0][1].text
    #     self.STAT_jd  = self.tree[0][2].text

    #     #Focuser
    #     self.Foc_connection = self.tree[1][0].text
    #     self.Foc_pos = self.tree[1][1].text
    #     self.Foc_move = self.tree[1][3].text
    #     self.Foc_complete = self.tree[1][4].text
    #     self.Foc_homing = self.tree[1][5].text

    #     #Rotator
    #     self.ROT_connection = self.tree[4][0].text
    #     self.ROT_position = self.tree[4][1].text
    #     self.ROT_moving = self.tree[4][3].text 
    #     self.ROT_goToComplete = self.tree[4][4].text
    #     self.ROT_homing = self.tree[4][5].text
    #     self.ROT_AltAzDerotate = self.tree[4][6].text
        
    #     #Mount
    #     self.MNT_connection = self.tree[7][0].text
    #     self.MNT_on_target  = self.tree[7][1].text
    #     self.MNT_moving = self.tree[7][3].text
    #     self.MNT_tracking = self.tree[7][3].text
    #     self.MNT_Ra2000 = self.tree[7][8].text
    #     self.MNT_Dec2000 = self.tree[7][9].text
    #     self.MNT_Alt = self.tree[7][13].text
    #     self.MNT_Azm = self.tree[7][12].text
    #     self.MNT_AzmMotor = self.tree[7][20].text
    #     self.MNT_AltMotor = self.tree[7][21].text
    #     self.MNT_PointingModel = self.tree[7][22].text
    #     self.MNT_AzmMotorError = self.tree[7][16].text
    #     self.MNT_AltMotorError = self.tree[7][17].text
    #     self.MNT_AltRMSErrorArcsec = self.tree[7][15].text
    #     self.MNT_AzmRMSErrorArcsec = self.tree[7][14].text


        
    #    #Temperatures - NEEDS WORKING! DROPS OUT WHEN FOCUSER DISCONNECT
    #     if self.Foc_connection == &#34;True&#34;:
    #        try:
    #            self.TEMP_pri = self.tree[9][0].text
    #            self.TEMP_amb = self.tree[9][1].text
    #            self.TEMP_sec = self.tree[9][2].text
    #            self.TEMP_backp = self.tree[9][3].text
    #            self.TEMP_m3 = self.tree[9][4].text
    #        except:
    #            print(&#39;There was an issue connecting the temperature sensors for the mirrors.&#39;)

    #     #Fans
    #     self.FANS_state = self.tree[10][0].text

    def update(self):
        &#34;&#34;&#34;
        This function runs the __init__ function again to update the stored variables in self. 
        
        Args:
            None

        Returns: 
            True
        
        &#34;&#34;&#34;
        self.__init__()
        return True


    def getALL(self):
        &#34;&#34;&#34;
        Prints all data that is available from PWI4 is a list. 
        
        Args:
            None

        Returns: 
            A list of parameters and their values
        &#34;&#34;&#34;
        self.update()
        ALL=self.status
        print(ALL)
        return ALL

    def getRA2000(self):
        &#34;&#34;&#34;
        A function that prints the current Right Ascension (RA) in the J2000 epoch of the mount/telescope.
        
        Args:
            None

        Returns:
            RA_J2000 in the format HH:MM:SS
        &#34;&#34;&#34;
        self.update()
        RA = self.MNT_Ra2000

        RA_hour = RAconverter_DectoHH(float(RA))
        return RA_hour
    
    def getDEC2000(self):
        &#34;&#34;&#34;
        A function that prints the current Declination (DEC) in the J2000 epoch of the mount/telescope.
        
        Args:
            None

        Returns:
            DEC_J2000 in the format DD:MM:SS
        &#34;&#34;&#34;
        
        self.update()
        DEC = self.MNT_Dec2000
        DEC_hour = DecConverter_DecitoDD(float(DEC))
        return DEC_hour
    

    def getFocuserPos(self):
        &#34;&#34;&#34;
        A function that prints the current position of the focuser in the telscope. 
        The units of the position is in microns.
        
        Args:
            None

        Returns:
            The position of the focuser in microns if the focuser is connected
            If the focuser is not connected, a reply is sent about the focuser not being connected
        &#34;&#34;&#34;
        self.update()
        if self.FOC_connection == &#34;true&#34;:
            print(&#39;The current position of the focuser is %s microns&#39;%(self.FOC_pos))
            reply = &#34;The current position of the focuser is %s microns&#34;%(self.FOC_pos)
            return reply
        else:
            print(&#39;The focuser is not connected to PWI4. Please use .ConnectFOC() to connect the focuser to PWI4.&#39;)
            reply = &#39;The focuser is not connected to PWI4. Please use .ConnectFOC() to connect the focuser to PWI4.&#39;
            return reply

    def getRotatorPos(self):
        &#34;&#34;&#34;
        A function that prints the current position of the rotator.
        The units of the position of the rotator is in degrees. 

        Args:
            None
        
        Returns:
            The current position of the rotator in degrees
        &#34;&#34;&#34;
        self.update()
        if self.ROT_connection == &#34;true&#34;:
            print(&#39;The current position of the rotator is %s degrees&#39;%(self.ROT_pos))
            reply = &#39;The current position of the rotator is %s degrees&#39;%(self.ROT_pos)
            return reply
        else:
            print(&#34;The rotator is not connected to PWI. Try the command: ConnectFOC()  &#34;)
            reply = &#39;The rotator is not connected to PWI. Try the command: ConnectFOC() &#39;
            return reply
    
    def getStatus(self):
        &#34;&#34;&#34;
        Prints a status message with the current RA and DEC in J2000 epoch, the 
        current UTC time. The message also gives a message whehter the telescope 
        is moving and/or tracking. Finally it prints whether the mount, focuser and rotator is
        connected to the PWI. 
        
        Args:
            None

        Returns:
            The status message
        
        &#34;&#34;&#34;
        self.update()
        RA = self.MNT_Ra2000
        DEC = self.MNT_Dec2000
        Alt = self.MNT_Alt
        Azm = self.MNT_Azm
        Moving = self.MNT_slewing
        Mnt = self.MNT_connection
        Foc = self.FOC_connection
        tracking = self.MNT_tracking
        Rot = self.ROT_connection
        
        
        reply = &#34;The telescope is pointed at RA: %s, DEC:%s (J2000) / Alt: %.4f, Azm: %.4f. \n&#34; %(RA,DEC,float(Alt),float(Azm))
        print(&#39;The telescope is pointed at RA: %s, DEC:%s (J2000) / Alt: %.4f, Azm: %.4f.&#39; %(RA,DEC,float(Alt),float(Azm)))

        if Moving == &#34;False&#34;:
            print(&#39;The telescope is not moving.&#39;)
            reply += &#39;The telescope is not moving.\n&#39;
        elif Moving == &#34;True&#34;:
            print(&#39;The telescope is moving.&#39;)
            reply += &#39;The telescope is moving.\n&#39;
            
        if tracking == &#34;True&#34;:
            print(&#39;The telescope is tracking.&#39;)
            reply += &#39;The telescope is tracking \n&#39;
        elif tracking == &#34;False&#34;:
            print(&#39;The telescope is NOT tracking.&#39;)
            reply += &#39;The telescope is NOT tracking \n&#39;
       
        
        print(&#39;Connections: \n&#39;)
        reply += &#39;Connections: \n&#39;
        if Mnt == &#34;true&#34;:
            print(&#39;The mount is connected to PWI&#39;)
            reply += &#39;The mount is connected to PWI \n&#39;
        elif Mnt == &#34;false&#34;:
            print(&#39;The mount is NOT connected to PWI&#39;)
            print(&#39;You should try connecting the mount with PWI using the command: .ConnectMNT()\n&#39;)
            reply += &#39;The mount is NOT connected to PWI \n&#39; 
            reply += &#39;You should try connecting the mount with PWI using the command: .ConnectMNT() \n&#39;
            
            
        if Foc == &#34;true&#34;:
            print(&#39;The focuser is connected to PWI&#39;)
            reply += &#39;The focuser is connected to PWI \n&#39;
        elif Foc == &#34;false&#34;:
            print(&#39;The focuser is NOT connected to PWI&#39;)
            print(&#39;You should try connecting the focuser with the command: .ConnectFOC()\n&#39;)
            reply += &#39;The focuser is NOT connected to PWI\n&#39;
            reply += &#39;You should try connecting the focuser with the command: .ConnectFOC() \n&#39;
            
        if Rot == &#34;true&#34;:
            print(&#39;The rotator is connected to PWI&#39;)
            reply += &#39;The rotator is connected to PWI\n&#39;
        elif Rot == &#34;false&#34;:
            print(&#39;The rotator is NOT connected to PWI&#39;)
            print(&#39;The rotator and focuser is linked in their connection.&#39;)
            print(&#39;You should maybe try to reconnect the focuser and theirby reconnect the rotator wit----h the functions: .DisconnectFOC() and .ConnectFOC()\n&#39;)
            reply += &#39;The rotator is NOT connected to PWI \n&#39;
            reply += &#39;The rotator and focuser is linked in their connection. \n&#39;
            reply += &#39;You should maybe try to reconnect the focuser and theirby reconnect the rotator with the functions: .DisconnectFOC() and .ConnectFOC() \n&#39;
        
        return reply
    

    def getMNT_CONNECT(self):
        &#34;&#34;&#34;
        A function that checks the connection between PWI and the mount of telescope.
        
        Args:
            None

        Returns:
            True if the mount is connected
            False if the mount is not connected
            False if the mount state is neither connected nor disconnected
        &#34;&#34;&#34;
        self.update()
        if self.MNT_connection == &#34;true&#34;:
            print(&#34;Mount is connected&#34;)
            return True
        if self.MNT_connection == &#34;false&#34;:
            print(&#34;Mount is NOT connected&#34;)
            return False
        else:
            print(&#34;ERROR: Mount state unable to be read!&#34;)
            return False


    def getFOC_CONNECT(self):
        &#34;&#34;&#34;
        A function that checks the connection between PWI and the focuser.

        Args:
            None
        
        Returns:
            True if the focuser is connected to PWI4
            False if the focuser is not connected to PWI4
            False if the focuser connection could not be reached
        &#34;&#34;&#34;
        self.update()
        
        if self.FOC_connection == &#34;true&#34;:
            print(&#34;Focuser is connected&#34;)
            return True
        if self.FOC_connection == &#34;false&#34;:
            print(&#34;Focuser is NOT connected&#34;)
            return False
        else:
            print(&#34;ERROR: Connection to focuser is not reachable&#34;)
            return False

    def getROT_CONNECT(self):
        &#34;&#34;&#34;
        A functions that checks the connection between PWI and the rotator. 
        Please note that the focuser and rotator are connected such that
        the focuser and rotator share the same connection to PWI. 
        So if the rotator is not connected, then the focuser won&#39;t bet connected either. 

        Args:
            None
        
        Returns:
            True when the rotator is connected to PWI4
            False when the rotator is not connected to PWI4
        &#34;&#34;&#34;

        self.update()
        
        if self.ROT_connection == &#34;true&#34;:
            print(&#34;Rotator is connected&#34;)
            return self.ROT_connection
        if self.ROT_connection == &#34;false&#34;:
            print(&#34;Rotator is not connected&#34;)
            return False
        else:
            print(&#34;ERROR: Rotator connection is not reachable.&#34;)
            return False

    def getIsTrackingOn(self):
        &#34;&#34;&#34;
        A function that checks if the telescope is tracking a target.

        Args:
            None
        
        Returns:
            True when the tracking is on
            False when the tracking is off
        &#34;&#34;&#34;
        self.update()
       
        if  self.MNT_tracking == &#34;true&#34;:
            print(&#34;Tracking is ON.&#34;)
            return True 
        else:
            print(&#34;Tracking is OFF.&#34;)
            return False 
        
    def getTrackingRMSError(self):
        &#34;&#34;&#34;
        A function that returns the Root Mean Square (RMS) of the tracking error for both the Alt and Azm motor. 
        
        Args:
            None
        Returns:
            Reply message witht the RMS error
        &#34;&#34;&#34;
        
        self.update()
        print(&#39;The RMS error on the Alt pointing is %.3f arcseconds&#39;%(float(self.MNT_AltRMSErrorArcsec)))
        print(&#39;The RMS error on the Azm pointing is %.3f arcseconds&#39;%(float(self.MNT_AzmRMSErrorArcsec)))

        reply = &#39;The RMS error on the Alt pointing is %.3f arcseconds \n&#39;%(float(self.MNT_AltRMSErrorArcsec))
        reply += &#39;The RMS error on the Azm pointing is %.3f arcseconds&#39;%(float(self.MNT_AzmRMSErrorArcsec))
        return reply

    def getTemps(self):
        &#34;&#34;&#34;
        Prints the temperature of the primary mirror, the ambient temperature, 
        the secondary mirror, the backplate and the M3. 
        The unit of temperature is Celcius.
        
        Returns:
            Message with temperature of the primary mirror, the ambient temperature, 
        the secondary mirror, the backplate and the M3 (in this order)
        &#34;&#34;&#34;
        
        
        self.update()
        Temp_PRI = self.TEMP_pri
        Temp_AMB = self.TEMP_amb
        Temp_SEC = self.TEMP_sec
        Temp_BPL = self.TEMP_backp
        Temp_M3 = self.TEMP_m3
        
        reply = &#34;&#34;
        
        #For the logging
        print(&#34;Temperature of primary:&#34;,Temp_PRI + &#34; C&#34;) 
        print(&#34;Temperature of ambient:&#34;,Temp_AMB + &#34; C&#34;) 
        print(&#34;Temperature of secondary:&#34;,Temp_SEC + &#34; C&#34;) 
        print(&#34;Temperature of backplate:&#34;,Temp_BPL + &#34; C&#34;)
        print(&#34;Temperature of M3:&#34;,Temp_M3 + &#34; C&#34;) 
        
        #for the client
        reply += &#34;Temperature of primary: %s C \n&#34;%(Temp_PRI)
        reply += &#34;Temperature of ambient: %s C\n&#34;%(Temp_AMB)
        reply += &#34;Temperature of secondary: %s C\n&#34;%(Temp_SEC)
        reply += &#34;Temperature of backplate: %s C\n&#34;%(Temp_BPL)
        reply += &#34;Temperature of M3: %s C\n&#34;%(Temp_M3)
        
        return reply


    def MoveFocuserPos(self,position):
        &#34;&#34;&#34;
        A function that moves the focuser position. The position is given 
        is units of microns. 
        Moving the focuser to 10300 microns would be as:
            MoveFocuserPos(10300) 
        
        
        Args: 
            The new position of the focuser given in microns
            
            
        Returns:
            True when finished moving 
            False if timeout occurs
            False if the end position does not match the target position within 5 microns of the target position
        &#34;&#34;&#34;
        self.update()

        #Checks wheter the wanted position is already the current position. DOES NOT WORK FOR SOME REASON???
        if &#34;%s&#34;%(position) == self.FOC_pos:
            print(&#39;The new requested position is already the current position of the focuser. Nothing will happen.&#39;)
            return True

        if position &lt; 0:
            print(&#39;The position is less than 0 microns. The movement will NOT be executed&#39;)
            return False

        #Sends command to change position of focuser
        cmd=requests.get(self.link+&#34;focuser/goto?target=%i&#34;%(position))
        time.sleep(3)
        self.update()
        print(&#39;Starting to move focuser&#39;)
        timeout_sec = 30 #Number of seconds before a timeout
        timeout = time.time() + timeout_sec #setting timeout
        while self.FOC_moving == &#34;false&#34;:
            print(&#39;Focuser moving, now at %s microns&#39;%(self.FOC_pos))
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;A timeout of %i seconds occured.&#39;%(timeout_sec))
                return str(&#34;Error&#34;)
        self.update()
        if abs(self.FOC_pos - position) &lt; 5:  #Checks if the new position is close enough to target. Set to 5 microns initially.
            print(&#39;The focuser has stopped at: %s microns&#39;%(self.FOC_pos))
            return True
        else: 
            print(&#39;The focuser did not reach the target. The current position is %s microns&#39;%(self.FOC_pos))
            return False
       
        
    def ConnectFOC(self):
        &#34;&#34;&#34;
        A function to connect PWI to the focuser. 
        Please note that the rotator is also connected with the focuser
        since they share the same port to PWI. 

        Args:
            None
        
        Returns:
            True if connection is complete
            False if timeout occurs
        &#34;&#34;&#34;
        FOC = requests.get(self.link+&#34;focuser/enable&#34;)
        print(&#39;Trying to connect focuser - please wait&#39;)
        self.update()
        timeout_sec = 10 #Set the number of seconds before timeout.
        timeout = time.time() + timeout_sec
        while self.FOC_connection == &#34;false&#34;:
            print(&#39;Waiting for focuser to connect&#39;)
            self.update()
            time.sleep(1)
            if time.time() &gt; timeout:
                print(&#39;A timeout of %i sec has occured.&#39;%(timeout_sec))
                return False #stop if the timeout is reached!
        return True

    def DisconnectFOC(self):
        &#34;&#34;&#34;
        A function that disconnects the focuser from PWI. 
        Please note that the focuser and rotator are connected to PWI 
        via the same connection. A disconnect of the focuser would therefor
        also disconnect the rotator.
        
        Returns:
            True for finished disconnection
            False for timeout
        &#34;&#34;&#34;
        self.update()
        if self.FOC_connection == &#34;false&#34;:
            print(&#39;The focuser is already disconnected&#39;)
            return True

        cmd = requests.get(self.link+&#34;focuser/disable&#34;)
        self.update()
        timeout_sec = 20
        timeout = time.time() + timeout_sec
        while self.FOC_connection == &#34;true&#34;:
            print(&#39;Trying to disconnect focuser&#39;)
            self.update()
            time.sleep(1)
            if time.time() &gt; timeout:
                print(&#39;A timeout of %i has occured.&#39;%timeout_sec)
                print(&#39;There was error disconnecting the focuser&#39;)
                return False
        return True
    
    # def MoveFocuserInc(self,increment):
    #     &#34;&#34;&#34;
    #     A function that moves the focuser in increments of microns. 
    #     The increments work with addition, i.e. moving the focuser 100 microns and then 
    #     move it again 200 microns results in the focuser moving a total of 300 microns.
        
    #     Example:
    #         The current position is 10000 microns.
    #         You want to move the focuser a further away. 
    #         MoveFocuserInc(100) would then move the focuser 100 microns to 10100 microns.
            
        
    #     Args:
    #         Increment to move focuser in the units of microns
            
    #     Returns:
    #         True when done with moving
    #         False if there is a timeout
    #         False if new target position is less than 0 microns.
    #         False if the new position is more than 5 microns from the target position. 
    #     &#34;&#34;&#34;
    #     self.update()
        
    #     self.FocInc_target = self.FOC_pos + increment

    #     if self.FocInc_target &lt; 0:
    #         print(&#39;The new target is less than 0 microns. The movement will NOT be executed&#39;)
    #         return False
    #     cmd = requests.get(self.link+&#34;?&amp;device=focuser&amp;cmd=move&amp;increment=%i&#34;%(increment))
    #     print(&#39;Offsetting the focuser by %i microns&#39; %(increment))
    #     timeout_sec = 25 #number of seconds before timeout
    #     timeout = time.time() + timeout_sec
    #     time.sleep(3)
    #     self.update()
    #     while self.FOC_moving == &#34;true&#34; and self.FOC_complete == &#39;false&#39;:
    #         print(&#39;Focuser moving, now at %s microns&#39;%(self.FOC_pos))
    #         time.sleep(2)
    #         self.update()
    #         if time.time() &gt; timeout:
    #             print(&#39;A timeout of %i seconds occured.&#39;%(timeout_sec))
    #             return False
    #     self.update()
    #     if abs(self.FOC_pos - self.FocInc_target) &lt; 5: #checks that the new position is within 5 micron of the target. 
    #         print(&#39;Focuser set at position: %s&#39;%(self.Foc_pos))
    #         return True
    #     else:
    #         print(&#39;The focuser did not reach STOPthe target position. The current position is %s microns&#39;%(self.Foc_pos))
    #         return False
    
    
    
    def FocSTOP(self):
        &#34;&#34;&#34;
        Stopping the focuser&#39;s movement. 
        This functions works, along with the other stop-functions, on a separate thread. 
        This ensures the function can always be called, by another terminal with the client running, even if another function is currently being executed. 
        
        Returns:
            True when focuser has been stopped
            False when a timeout occurs
        &#34;&#34;&#34;
        print(&#39;Stopping the focuser - please wait&#39;)
        cmd = requests.get(self.link+&#34;focuser/stop&#34;)
        timeout_sec = 20 #number of seconds before timeout
        timeout = time.time() + timeout_sec
        time.sleep(3)
        self.update()
        while self.FOC_moving == &#34;true&#34;:
            print(&#39;Focuser is still moving, now at %s microns, please wait&#39;%(self.FOC_pos))
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;A timeout of %i seconds occured.&#39;%(timeout_sec))
                return False
        print(&#34;The focuser has now stopped, at %s microns&#34;%(self.FOC_pos))
        return True
    
    
        
    # def FocFindHome(self):
    #     &#34;&#34;&#34;
    #     A function that homes the focuser. The homing-procedure moves the focuser from the current position to 0 microns, 
    #     then stops and then move the focuser to 1000 microns. This procedure takes on the order of 1-2 minutes
    #     depending on the initial starting position. 
        
    #     Returns:
    #         True when the homing procedure is finished
    #         False if there is a timeout. 
    #     &#34;&#34;&#34;
    #     print(&#39;Homing - please wait&#39;)
    #     print(&#39;The position of the focuser before moving is %s microns&#39;%(self.FOC_pos))
    #     cmd = requests.get(self.link+&#34;?&amp;device=focuser&amp;cmd=findhome&#34;)
    #     timeout_sec = 120 #nuber of seconds before timeoutting
    #     timeout = time.time() + timeout_sec
    #     time.sleep(2)
    #     self.update()
    #     while self.FOC_homing == &#34;true&#34; and self.FOC_moving == &#34;true&#34;:
    #         print(&#39;The focuser is homing, currently at %s microns - please wait&#39; %(self.FOC_pos))
    #         self.update()
    #         time.sleep(2)
    #         if time.time() &gt; timeout:
    #             print(&#39;There has been a timeout of %i seconds.&#39;%(timeout_sec))
    #             return False
            
    #     print(&#39;The focuser has finished homing and is at %s microns&#39; %(self.FOC_pos))
    #     print(&#39;\n The focuser will now move to 1000 microns. \n&#39;)
    #     time.sleep(2)
    #     self.update()
    #     while self.FOC_moving == &#34;true&#34;:
    #         print(&#39;The focuser is moving and is currently at %s microns - please wait&#39;%(self.FOC_pos))
    #         self.update()
    #         time.sleep(2)
    #         if time.time() &gt; timeout+60:
    #             print(&#39;There has been a timeout of %i seconds&#39;%(60+timeout_sec))
    #             return False
    #     print(&#39;The focuser has stopped moving and is positioned at %s&#39;%(self.FOC_pos))
    #     return True
        
    
    
    #     #This function starts the focuser&#39;s auto-focusing function. 
    #     #However this does not work, since the function needs MAXIM-DL in PWI4
    # def FocAutofocus(self):
    #     print(&#39;The focuser will start autofocusing - please wait&#39;)
        
    #     cmd = requests.get(self.link+&#34;?&amp;device=focuser&amp;cmd=startautofocus&#34;)
    
    #     return
            
        

    def ConnectMNT(self):
        &#34;&#34;&#34;
        A function that connects PWI to the mount of the telescope and energizes 
        the motors (effectively turning them on). 
        Once the motors are energized, they CANNOT be moved by hand.  

        Args:
            None
        
        Returns:
            True when connected and motors are energized
            False if there is a timeout
        &#34;&#34;&#34;
        
        self.update()
        if self.MNT_connection == &#34;true&#34; and self.MNT_AzmMotor == &#34;true&#34; and self.MNT_AltMotor == &#34;true&#34;:
            print(&#39;The mount is already connected and energized.&#39;)
            return True
        cmd = requests.get(self.link+&#34;mount/connect&#34;)
        self.update()
        time.sleep(1)
        timeout_sec = 15 #Number of seconds before timeoutting
        timeout = time.time() + timeout_sec
        while self.MNT_connection == &#34;false&#34;:
            print(&#39;Trying to connect mount. Please wait&#39;)
            self.update()
            time.sleep(1)
            if time.time() &gt; timeout:
                print(&#39;The connection timed-out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;Mount is connected. Energizing motors now - please wait&#39;)
        time.sleep(1)
        enableAzm = requests.get(self.link+&#34;mount/enable/axis=0&#34;)
        enableAlt = requests.get(self.link+&#34;mount/enable/axis=1&#34;)
        time.sleep(2)
        self.update()
        #I dont know if I can use the same timeout method here since it is in the same function?
        while self.MNT_AzmMotor == &#34;false&#34; and self.MNT_AltMotor == &#34;false&#34;:
            print(&#39;Energizing motors - please wait&#39;)
            time.sleep(1)
            self.update()
            if time.time() &gt; timeout + 30:
                print(&#39;There was a timeout during the energizing of the motors&#39;)
                return False
        print(&#39;Motors are energized! You can proceed.&#39;)
        return True


    def DisconnectMNT(self):
        &#34;&#34;&#34;
        A function that disconnects the mount from PWI.
        The opposite function - &#34;ConnectMNT()&#34; - connects the mount to PWI4.
        
        Returns:
            True when disconnection is finished
            False if there is a timeout before disconnecting
        &#34;&#34;&#34;
        self.update()
        if self.MNT_connection == &#34;false&#34;:
            print(&#39;The mount is already disconnected&#39;)
            return True
        #disableAzm = requests.get(self.link+&#34;mount/disable?axis=0&#34;)
        #disableAlt = requests.get(self.link+&#34;mount/disable?axis=1&#34;)
        time.sleep(2)
        cmd = requests.get(self.link+&#34;mount/disconnect&#34;)
        self.update()
        time.sleep(2)
        timeout_sec = 15 #set the number of seconds before timeout
        timeout = time.time()+timeout_sec
        while self.MNT_connection == &#34;true&#34;:
            print(&#39;Trying to disconnect mount. Please wait&#39;)
            self.update()
            time.sleep(2)
            if time.time() &gt; timeout:
                print(&#39;A timeout of %i sec has occured.&#39;%(timeout_sec))
                return False #stop if the timeout is reached!
        print(&#39;Mount disconnected!&#39;)
        return True
     
    def MntMotorReset(self):
        &#34;&#34;&#34;
        The function reset the motors. It calls two functions: Firstly the function
        MntMotorDisable and then MntMotorEnable. The first function one de-energizes the motors, 
        while the second function energizes the motors. The mount motors have then been reset.
        
        Returns:
            True when resetting the mount is finished
            False if the resetting does not succed
        
        &#34;&#34;&#34;
        print(&#39;Starting to reset mount motors&#39;)
        try:
            self.MntMotorDisable()
        except Exception as e:
            print(e)
        
        try:
            self.MntMotorEnable()
        except Exception as e:
            print(e)
        self.update()
        
        if self.MNT_AltMotor != &#34;true&#34; and self.MNT_AzmMotor != &#34;true&#34;:
            print(&#39;There was an error in the resetting of the motors&#39;)
            return False
        
        return True


    def checkFormatRaDec(self,RA,DEC):
        &#34;&#34;&#34;
        A function that checks the format of the input which is Right Ascension (RA) 
        and Declination (DEC) of a target. 
        
        
        The correct format for RA will be:
            HH:MM:SS.SS
        
        The correct format for DEC will be:
            DD:MM:SS.SS
        
        It is possible to parse a negative DEC. A correct example would be:
            -15:50:06.50
            
        Args:
            Right Ascension of target, Declination of target
        
        Returns:
            The number of errors in the format
        &#34;&#34;&#34;
        
        #Split up the input into 3 parts, not sure if this is a good idea to manually set it to max 3 parts. We&#39;ll see. 
        RA_hr,RA_mm,RA_ss = RA.split(&#34;:&#34;,2) 
        DEC_deg,DEC_mm,DEC_ss = DEC.split(&#34;:&#34;,2)
        print(RA_hr,RA_mm,RA_ss)
        print(DEC_deg,DEC_mm,DEC_ss)
        format_error = 0
        if len(RA_ss) == 5:
            if (RA_ss)[2] == &#34;:&#34;:
                print(&#39;Input error for RA. There is a &#34;:&#34; between the seconds input.&#39;)
                print(&#39;This should be a &#34;.&#34;&#39;)
                format_error += 1
        if len(DEC_ss) == 4:
            if (DEC_ss)[2] == &#34;:&#34;:
                print(&#39;Input error for DEC. There is a &#34;:&#34; between the seconds input.&#39;)
                print(&#39;This should be a &#34;.&#34;&#39;)
                format_error += 1        
        return format_error
        


    def checkFormatAltAzm(self, Alt,Azm):
        &#34;&#34;&#34;
        A function that checks the format of the inputs which is the Altitude (Alt) 
        and Azimuth (Azm) of a target. 
        
        The unit of the inputs are in degrees.
        
        The functions makes sure that the Alt is above 0 and below 90 degrees and
        the Azm is between 0 degrees and 360 degrees. 
        
        Args:
            Altitude in degrees, Azimuth in degrees
            
        Returns:
            Number of errors in format. If #errors &gt; 0, then there is an issue with the format.
        
        &#34;&#34;&#34;
        
        
        error = 0
        if Alt &gt; 90:
            print(&#39;Error:&#39;)
            print(&#39;Altitude is in degrees and should be below 90 degrees&#39;)
            error += 1
        if Alt &lt; 0: 
            print(&#39;Error:&#39;)
            print(&#39;Altitude is in degrees and should above 0 degrees&#39;)
            error += 1
        if Azm &gt; 360:
            print(&#39;Error:&#39;)
            print(&#39;Azimuth is in degrees and should be below 360 degrees&#39;)
            error += 1
        if Azm &lt; 0:
            print(&#39;Error:&#39;)
            print(&#39;Azimuth is in degrees and should be above 0 degrees&#39;)
            error += 1
        
        return error
    


    def MntMoveRaDecJ2000(self):
        &#34;&#34;&#34;
        A function that starts the observation of a target. The target coordinates
        are passed through the function &#34;setTargetRaDecJ2000(Ra,Dec)&#34;. This means
        that the coordinates are first set with &#34;setTargetRaDecJ2000(Ra,Dec)&#34; and then
        this function is used to move the mount.
        
        The target coordinates are then checked for the format. If there are no errors, 
        the target is then checked if it on the night sky with the Observer at Mount Kent, Queensland Australia .
        
        Per version 0.0.1:
        The minimum elevation, called horizon_limit, above the horizon is set to 16 deg.
        This is set in the config file &#34;PWI4_config.py&#34;
        
        If target is above the minimum elevation, the mount will move to the target and track the target.
        
        The mount will stay on target until otherwise told or until the target moves below the horizon limit.

        Returns:
            True when on target
            False if there is a error in the format of RA or DEC
            False if the target is below the minimum elevation above the horizon
            False if there is a timeout
        &#34;&#34;&#34;
        self.update()
        #Load in the RA and DEC (in epoch J2000) from self
        RA = self.RAJ2000
        DEC = self.DECJ2000
        

        #################################################################################
        #This piece checks the format of the input is correct. The following
        #formats are accepted: HH:MM:SS.SS         
        format_err = self.checkFormatRaDec(RA,DEC)        
        if format_err != 0:
            print(&#34;Errors in input format. Tracking will NOT be started&#34;)
            return False
        
        
        ##################################################################################
        
        ##################################################################################
        #Now that the format is checked, the RA and DEC is sent to song_star_checker_AUTOTUNE.py (SSCA)
        #The SSCA script uses the ephem package to where on the sky the star is. 
        #The script then checks whether the coordinates are then correct. 
        # If they are correct, RA and DEC are then sent to SSCA to get the alt,azm
        # If alt is above horizon-limit, then it will proceed to track that target
        
        check = SSCA.coordinates.coordinate_check(self,RA,DEC)
        horizon_limit = conf.NOVO_lower_limit #the alt-limit in degrees for the telescope to track
        ###### PLEASE NOTE THAT PWI WILL TRACK THE TARGET TO THE LIMIT SET IN PWI4 (LOWER TRACKING LIMIT) 
        #I have now set it to 15 deg both here and in PWI, but if we want to change it in the future, we need to change it both places.
        if check == 0:
            star_init = SSCA.star_pos.__init__(self,site=conf.site) #sets the site for Mt. Kent
            star_alt = SSCA.star_pos.star_alt(self,RA,DEC) #uses the SSCA script to get alt
            star_azm = SSCA.star_pos.star_az(self,RA,DEC) #uses the SSCA script to get azm
            #print(&#39;Star alt, star azm&#39;)
            #print(star_alt,star_azm)
            if (str(star_alt)[1:2]) == &#39;:&#39;: #The return value of the altitude of the star, when the Alt is below 10, is i.e. 8 and not 08. The code crashed beforehand due to &#34;8:&#34; not being an integer
                if int(str(star_alt)[0:1]) &gt; horizon_limit:
                    Ra_dec = RAconverter_HHtoDec(RA)
                    Dec_dec = HMS2deg(ra = &#34;&#34;,dec =&#34;%s&#34;%(DEC))
                    print(&#39;The target is above the horizon-limit of %i deg. The tracking will begin momentarily.&#39;%(horizon_limit))
                    track = requests.get(self.link+&#34;mount/gotoradecj2000?ra_hours=%.4f&amp;dec_degs=%.5f&#34;%(float(Ra_dec[0]),float(Dec_dec)))
                    print(track)
                    timeout_sec = 60 #number of seconds before timeout
                    timeout = time.time() + timeout_sec
                    time.sleep(3)   
                    self.update()
                    while self.MNT_slewing == &#34;true&#34;:
                        print(&#39;Not on target yet, please wait&#39;) 
                        time.sleep(2)                   
                        self.update()
                        if time.time() &gt; timeout:
                            print(&#39;A timeout of %i seconds has occured&#39;%(timeout_sec))
                            return False
                    print(&#39;The telescope is on target&#39;)
                elif int(str(star_alt)[0:1]) &lt; horizon_limit:
                    print(&#39;The target is below the horizon-limit of %i deg&#39;%(horizon_limit))
                    print(&#39;The tracking will NOT be started.&#39;)
                    return False
                
                
            elif (str(star_alt)[2:3]) == &#39;:&#39;:    
                if int(str(star_alt)[0:2]) &gt; horizon_limit:
                    Ra_dec = RAconverter_HHtoDec(RA)
                    Dec_dec = HMS2deg(ra = &#34;&#34;,dec =&#34;%s&#34;%(DEC))
                    print(&#39;The target is above the horizon-limit of %i deg. The tracking will begin momentarily.&#39;%(horizon_limit))
                    track = requests.get(self.link+&#34;mount/goto_ra_dec_j2000?ra_hours=%.4f&amp;dec_degs=%.5f&#34;%(float(Ra_dec[0]),float(Dec_dec)))
                    timeout_sec = 60 #number of seconds before timeout
                    timeout = time.time() + timeout_sec
                    time.sleep(3)   
                    self.update()
                    while self.MNT_slewing == &#34;true&#34;:
                        print(&#39;Not on target yet, please wait&#39;) 
                        time.sleep(2)                   
                        self.update()
                        if time.time() &gt; timeout:
                            print(&#39;A timeout of %i seconds has occured&#39;%(timeout_sec))
                            return False
                    print(&#39;The telescope is on target&#39;)
                elif int(str(star_alt)[0:2]) &lt; horizon_limit:
                    print(&#39;The target is below the horizon-limit of %i deg&#39;%(horizon_limit))
                    print(&#39;The tracking will NOT be started.&#39;)
                    return False
        return True
 


    def stopTracking(self):
        &#34;&#34;&#34;
        A function that stops the mount tracking a target. 
        The opposite function - &#34;startTracking()&#34; - starts the tracking.
        
        Returns:
            True when tracking has stopped
            True if the mount has already stopped
            False if there is a timeout
            False if there is an unknown error
            
        
        &#34;&#34;&#34;
        #self.update()
        #if self.MNT_tracking == &#34;false&#34;:
        #    print(&#39;The mount has already stopped tracking&#39;)
        #    return True


        stop = requests.get(self.link+&#34;mount/tracking_off&#34;)
        print(&#39;Stopping tracking request sent - please wait&#39;)
        self.update()
        timeout_sec = 20 #number of seconds before timeout
        timeout = time.time()+timeout_sec
        while self.MNT_tracking == &#34;true&#34;:
            print(&#39;Trying to stop tracking - please wait&#39;)
            time.sleep(1)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;This session has timed-out after %i seconds&#39; %timeout_sec)
                return False
        if self.MNT_tracking == &#34;false&#34;:
            print(&#39;The tracking is OFF and the mount has stoppped.&#39;)
            time.sleep(3)
            self.update()
            print(&#39;The current position of the telescope is %g\xb0 %g\xb0 (Alt,Azm)&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
        else: 
            print(&#39;Something went wrong trying to stop the tracking&#39;)
            return False
        return True

    def parkMount(self):
        &#34;&#34;&#34;
        A function that parks the mount to a parking position. The mount moves to the 
        parking position, tracks the position of the parking position for a very short amount of time
        and then stops tracking the parking position, thereby stopping the mount at the parking position.

        The parking position is set in the PW4_config.py file.
        
        The function uses the function &#34;stopTracking&#34; for stopping the tracking once the mount is on target.

        Args:
            None
        
        Returns:
            True when parking the mount is done 
            False if there was a timeout 
        &#34;&#34;&#34;
        park_alt = conf.park_alt # the altitude in deg where the telescope will be parked 
        park_azm = conf.park_azm # the azimuth in deg where the telescope will be parked
        print(&#39;The mount will be parked to the position %i\xb0, %i\xb0 (Alt,Azm)&#39;%(park_alt,park_azm))
        park = requests.get(self.link+&#34;mount/goto_alt_az?alt_degs=%s&amp;az_degs=%s&#34;%(park_alt,park_azm))
        timeout_sec = 60 #number of sec before timeout
        timeout = time.time() + timeout_sec
        time.sleep(3)
        self.update()
        while self.MNT_slewing == &#34;true&#34;:
            print(&#39;Mount still moving - please wait&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed out after %i seconds&#39; %(timeout_sec))
                return False
        time.sleep(2)
        self.stopTracking() #Stops the tracking of the parking point
        
        return True
        
   
    def MountSTOP(self):
        &#34;&#34;&#34;
        This function stops all mount movements when sent to PWI. 
        Please note that this function is called by the daemon on a different server (server2)
        to make sure this stop function can be called even if other functions are running.
        
        Example: The mount is moving to a new target, but needs to be stopped.
        The &#34;MountSTOP&#34; command is sent, uses server2, which only checks for stop-functions, 
        and stops the mount.
        
        Args:
            None

        Returns:
            True when the mount is stopped
            False if there is a timeout
        &#34;&#34;&#34;
        if self.MNT_tracking == &#39;false&#39;:
            print(&#39;Tracking is already off. The stop command will still be executed!&#39;)
            #A good idea? Otherwise, if there is something wrong and you can&#39;t stop the mount because of the if-statement.

        cmd = requests.get(self.link+&#39;mount/stop&#39;)
        timeout_sec = 15 #Number of seconds before timeout
        timeout = time.time()+timeout_sec
        while self.MNT_slewing == &#34;true&#34; and self.MNT_tracking == &#34;true&#34;:
            print(&#39;Waiting for mount to stop - please wait&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed-out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The mount has stopped&#39;)
        return True

    def MntMotorEnable(self):
        &#34;&#34;&#34;
        A function that energizes the mount motors (Alt and Azm). 
        Essentially turning the motors on.
        Once the motors are energized, they CANNOT be moved by hand.

        Args: 
            None
        
        Returns:
            True when the motors are energized
            False if there is a timeout
        &#34;&#34;&#34;
        print(&#34;Sending command to energize motors - please wait&#34;)
        cmdAzm = requests.get(self.link+&#34;mount/enable?axis=0&#34;)
        cmdAlt = requests.get(self.link+&#34;mount/enable?axis=1&#34;)
        time.sleep(1)
        self.update()
        timeout_sec = 10 #number of seconds before timing out
        timeout = time.time() + timeout_sec
        while self.MNT_AltMotor == &#34;false&#34; and self.MNT_AzmMotor == &#34;false&#34;:
            self.update()
            print(&#39;Waiting for motors to energize - please wait&#39;)
            time.sleep(2)
            if time.time() &gt; timeout:
                print(&#34;The session has timed out after %i seconds&#34;%(timeout_sec))
                return False
        print(&#39;The motors have energized.&#39;)
        return True
        
    def MntMotorDisable(self):
        &#34;&#34;&#34;
        A function that de-energizes the mount motors (Alt and Azm).
        Essentially turning the motors off. 
        Once the motors are de-energized, you&#39;ll be able to move the mount by hand - but please be careful in doing so. 
        
        Args:  
            None

        Returns: 
            True when the motors are disabled
            False if there is a timeout
        &#34;&#34;&#34;
        print(&#39;Sending command to de-energize motors - please wait&#39;)
        cmdAzm = requests.get(self.link+&#34;mount/disable?axis=0&#34;)
        cmdAlt = requests.get(self.link+&#34;mount/disable?axis=1&#34;)
        time.sleep(1)
        self.update()
        timeout_sec = 10 #number of seconds before timeout
        timeout = time.time() + timeout_sec
        while self.MNT_AltMotor == &#34;true&#34; and self.MNT_AzmMotor == &#34;true&#34;:
            print(&#34;Trying to energize motors - please wait&#34;)
            time.sleep(1)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The motors have been disabled.&#39;)
        return True
        
    # def MntMoveIncRaDec(self,RA,DEC):
    #     &#34;&#34;&#34;
    #     A function that moves the mount in increments given by the user, for 
    #     the movement in the Right Ascension and Declination (RA, DEC). 
        
    #     The increments add i.e. an increment of (5,10) and afterwards a new increment
    #     of (10,10) would result in a total movement of (15,20) in RA/Dec respectively.
        
    #     *PLEASE NOTE*: The inputs for RA and DEC increments are in arcseconds. 
        
    #     Args: 
    #         Increments in arcseconds for Right Ascension and Declination
    #     Returns:
    #         True when movement is done and the mount is on target and tracking.
    #         False if there is a timeout.
    #     &#34;&#34;&#34;
        
        
    #     print(&#39;Moving the mount %i arcsec, %i arcsec (Ra,Dec) - please wait&#39;%(RA,DEC))
    #     cmd = requests.get(self.link+&#34;?&amp;device=mount&amp;cmd=move&amp;incrementra=%.8f&amp;incrementdec=%.8f&#34;%(RA,DEC))
    #     timeout_sec = 15 #number of seconds before timing out. 
    #     timeout = time.time() + timeout_sec
    #     time.sleep(2)
    #     self.update()
    #     while self.MNT_on_target == &#34;False&#34;:
    #         print(&#39;Still moving mount - please wait&#39;)
    #         time.sleep(1)
    #         self.update()
    #         if time.time() &gt; timeout:
    #             print(&#39;The session timed out after %i seconds&#39;%(timeout_sec))
    #             return False
    #     print(&#39;The movement is done. The telescope is now tracking.&#39;)
    #     return True
        
    
    # def MntMoveIncAltAzm(self,Alt,Azm):
    #     &#34;&#34;&#34;
    #     A function that moves the mount in increments in Altitude and Azimuth (Alt,Azm).
    #     The increments are given by the user with the unit of *arcseconds*. 
        
    #     It should be noted that the increments add meaning if you add (50,20) and 
    #     then add another (10,10), the total movement will be (60,30) in Alt and Azm respectively.
        
    #     Args:
    #         Increments to move the mount in Altitude and Azimuth in the units of arcseconds
            
    #     Returns:
    #        True when movement in done and mount is on target and tracking
    #        False if there is a timeout.
    #     &#34;&#34;&#34;
        
    #     print(&#39;Moving the mount - please wait&#39;)
    #     cmd = requests.get(self.link+&#34;?&amp;device=mount&amp;cmd=move&amp;incrementazm=%.4f&amp;incrementalt=%.4f&#34;%(Azm,Alt))
    #     time.sleep(2)
    #     timeout_sec = 15 #number of seconds before timing out
    #     timeout = time.time() + timeout_sec
    #     while self.MNT_on_target == &#34;False&#34;:
    #         print(&#39;Mount still moving - please wait&#39;)
    #         time.sleep(1)
    #         self.update()
    #         if time.time() &gt; timeout:
    #             print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
    #             return False
    #     print(&#39;The movement is done. The tracking is on.&#39;)
    #     return True
    
    

    def MntMoveRaDec(self):
        &#34;&#34;&#34;
        A function that moves the mount to the Right Ascension and Declination (RA and DEC). 
        The input is loaded in from the function &#34;setTargetRaDec(Ra,Dec)&#34; where the target
        coordinates are set. This means you first set the target coordinates with 
        &#34;setTargetRaDec(Ra,Dec)&#34; and then move the mount with this function.

        Args:
            None
            
        Returns:
            True when the movement is finished and the mount is on target and tracking
            False if there is a timeout
            False if there is an error in the format of the input
            False if the target is below horizon limit - which is set in the PWI4_config file
        &#34;&#34;&#34;
        
        self.update()
        RA = self.RA
        DEC = self.DEC

        print(RA,DEC)
        
        print(&#39;Moving mount - please wait&#39;)
        check = self.checkFormatRaDec(RA,DEC)
        if check != 0:
            print(&#39;Error&#39;)
            print(&#39;There is an error in the format of the RA/DEC. Tracking will NOT be started.&#39;)
            return False
        
        star_init = SSCA.star_pos.__init__(self,site=conf.site)
        star_alt = SSCA.star_pos.star_alt(self,RA,DEC)
        star_azm = SSCA.star_pos.star_az(self,RA,DEC)
        horizon_limit = conf.NOVO_lower_limit #tracking limit. 
        alt_degree,_,_ = str(star_alt).split(&#34;:&#34;)
        print(alt_degree)
        
        if int(alt_degree) &gt; horizon_limit:
            print(&#39;Target is above horizon limit of %i degrees&#39;%(horizon_limit))
            print(&#39;The tracking will start momentarily - please wait&#39;)
            Ra_dec = RAconverter_HHtoDec(RA)
            Dec_dec = HMS2deg(ra = &#34;&#34;,dec =&#34;%s&#34;%(DEC))
            print(Ra_dec,Dec_dec)
            cmd = requests.get(self.link+&#34;mount/goto_ra_dec_apparent?ra_hours=%.5f&amp;dec_degs=%.5f&#34;%(float(Ra_dec[0]),float(Dec_dec)))
            timeout_sec = 60 #number of seconds before timing out
            timeout = time.time() + timeout_sec
            time.sleep(2)
            self.update()
            while self.MNT_slewing == &#34;true&#34;:
                print(&#39;Mount is still moving to target - please wait&#39;)
                time.sleep(2)
                self.update()
                if time.time() &gt; timeout: 
                    print(&#39;The session has timed out after %i seconds&#39; %(timeout_sec))
                    return False
            print(&#39;The telescope is on target and is tracking&#39;)
        
        elif int(alt_degree) &lt; horizon_limit: 
            print(&#39;The target is below the horizon limit of %i degrees&#39;%(horizon_limit))
            print(&#39;Tracking will NOT be started!&#39;)
            return False

        return True

        
    def MntMoveAltAzm(self):
        &#34;&#34;&#34;
        A function to move to the mount to an Altitude and Azimuth which is 
        first set with the function &#34;setTargetAltAzm(Alt,Azm)&#34;. This means
        you have to first set the Alt/Azm coordinates with &#34;setTargetAltAzm(Alt,Azm)&#34;
        and then use this function to move the mount.
        
        The input is first checked for format errors and if there are no errors,
        and the target altitude is above the horizon limit - which is set to 15 degrees above horizon per version 0.0.1 -
        gives the commmand to move the mount to the given coordinates. 

        Args:
            None
        
        Returns:
            True when the mount has finished the movement and is on target and tracking
            False if there is an error in the format of the input
            False if the target is below the horizon limit 
        &#34;&#34;&#34;
        self.update()
        #Loading in the altitude and azimuth
        Alt = self.Alt
        Azm = self.Azm
        
        #check function for Alt/azm
        errors = self.checkFormatAltAzm(Alt,Azm)
        if errors != 0:
            print(&#39;There was an error with the Alt/Azm format&#39;)
            print(&#39;The movement will NOT begin&#39;)
            return False
        horizon_limit = conf.NOVO_lower_limit #degrees above the horizon where the telescope cannot track below. SHOULD BE CHANGE ALSO IN PWI4 and in MntMoveRaDec and MntMoveRaDecJ2000
#        if Alt &gt; 90:
#            print(&#39;The altitude must be lower than 90 deg. The mount will NOT be moved&#39;)
#            return False
        if Alt &lt; horizon_limit:
            print(&#39;The altitude must be higher than %i degrees. The mount will NOT be moved&#39;%(horizon_limit))
            return False

        
        print(&#39;Starting movement in a moment - please wait&#39;)
        print(&#39;Starting position is at %.4f\xb0 %.4f\xb0 (Alt/Azm)&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
        cmd = requests.get(self.link+&#34;mount/goto_alt_az?alt_degs=%s&amp;az_degs=%s&#34;%(Alt,Azm))
        timeout_sec = 60 #number of seconds before timing out.
        timeout = time.time() + timeout_sec
        time.sleep(2)
        self.update()
        while self.MNT_slewing == &#34;true&#34;:
            print(&#39;Still moving the mount - please wait&#39;)
            self.update()
            time.sleep(2)
            if time.time() &gt; timeout:
                print(&#39;This session has timedout after %i seconds&#39;%(timeout_sec))
                print(&#39;The position at timeout was Alt: %s and Azm: %s&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
                return False
        print(&#39;The mount is on target and is tracking at %.3f\xb0,%.3f\xb0 (Alt/Azm)&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
        return True
        
    def startTracking(self):
        &#34;&#34;&#34;
        A function that starts the tracking. The mount will track the current position of the telescope/mount.
        
        Args:
            None
        
        Returns:
            True when tracking is on
            False if there is a timeout
        &#34;&#34;&#34;
        print(&#39;Starting tracking - please wait&#39;)
        
        cmd = requests.get(self.link+&#34;mount/tracking_on&#34;)
        
        timeout_sec = 15 # number of seconds before timing out
        timeout = time.time() + timeout_sec
        time.sleep(1)
        self.update()
        while self.MNT_tracking == &#34;False&#34;:
            print(&#39;Not tracking yet - please wait&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout: 
                print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;Tracking is now on&#39;)
        return True
        
    
    def LoadPointingModel(self,filename):
        &#34;&#34;&#34;
        This function loads in a pointing model from Documents/PlaneWave Instruments/PWI4/Mount/
        The filename has some restrictions:
            1. only alphanumeric characters, underscore and hyphen
            2. must end in &#34;.pxp&#34;
            3. Must be in the path &#34;Documents/PlaneWave Instruments/PWI4/Mount&#34; on the computer
        Example of command:
            LoadPointingModel(&#39;Model1.pxp&#39;)
            
        Args:
            Filename of pointing model you want to import
        Returns:
            True when pointing model is loaded
            False if name of new pointing model does not correspond to the filename           
        &#34;&#34;&#34;
        
        
        name, filetype = filename.split(&#39;.&#39;)
        if filetype != &#34;pxp&#34;:
            print(&#39;Error&#39;)
            print(&#39;The filetype must be .pxp!&#39;)
            return
        cmd = requests.get(self.link+&#34;mount/model/load?filename=%s&#34;%(filename))
        time.sleep(2)
        self.update()
        if self.MNT_PointingModel == filename:
            print(&#39;The poiting model %s has been loaded successfully.&#39;%(filename))
            return True
        else:
            print(&#39;There was an error loading in the pointing model.&#39;)
            return False



       
    # def setTrackingRates(self,RArate,DECrate):
    #     &#34;&#34;&#34;
    #     A function that sets the tracking rates, expressed as an offset to the standard sidereal rate. 
    #     If both inputs are 0, the tracking will be at the sidereal rate. 
    #     The units for the RArate and DECrate is arcseconds per sec.
    #     &#34;&#34;&#34;
        
    #     cmd = requests.get(self.link+&#34;?&amp;device=mount&amp;cmd=trackingrates&amp;rarate=%.2f&amp;decrate=%.2f&#34;%(RArate,DECrate))
        
    #     return cmd
        

    #     #NOT DONE YET!


    def checkFormatArcsec(self,Arcsec):
        &#34;&#34;&#34;
        A function that checks the format of arcseconds. 
        Per version 0.0.1, the function simply checks whether the input is above 
        60 or below 0. This may be changed in future versions.
        
        Args:
            Input in arcseconds

        Returns:
            Number of errors in the format  
        &#34;&#34;&#34;
        
        print(&#39;Checking format - please wait&#39;)
        error = 0 #number of errors:
        if float(Arcsec) &gt; 60.0:
            print(&#39;Error:&#39;)
            print(&#39;The number of arc seconds need to be below 60&#39;)
            error += 1
        if float(Arcsec) &lt; 0.0:
            print(&#39;Error:&#39;)
            print(&#39;The number of arc seconds should be above 0&#39;)
            error +=1
        return error


    def startMntHoming(self):
        &#34;&#34;&#34;
        A function that starts the homing procedure in PWI4 for the mount. 
        *PLEASE NOTE*: Per version 0.0.1 this function crashes the simulator and
        has not been tested on a real telescope. It is therefor suggested to be very careful when
        using this function

        Args:
            None
        
        Returns:
            Per version 0.0.1: Nothing.
        &#34;&#34;&#34;

        self.update()
        print(&#39;Starting homing of the mount - please wait&#39;)
        cmd = requests.get(self.link+&#39;mount/find_home&#39;)
        return cmd


    def AddPointToModel(self,RA,DEC):
        &#34;&#34;&#34;
        A function that adds a point/target to current pointing model. It assigns the current telescope position (RA,DEC) to the input provided by 
        the user - which is also a RA and DEC in J2000 epoch. The input is checked for format errors before adding point to pointing model.
        The telescope start tracking when this command is executed.
        
        Example of command:
            AddPointToModel(&#34;04:35:55.33&#34;,&#34;16:30:29.5&#34;) #Aldebaran&#39;s J2000.0 coordinates.

        Args:
            RA and DEC in J2000 epoch to add to the current pointing model

        Returns:
            True when point is added to the pointing model
            False if there is a format error in the input
            False if there is a timeout
        &#34;&#34;&#34;
        
        
        print(&#39;Adding point to model - please wait&#39;)
        check = self.checkFormatRaDec(RA,DEC)
        if check != 0:
            print(&#39;There was an error in the format of RA/DEC&#39;)
            print(&#39;No point will be added to the pointing model&#39;)
            return False

        cmd = requests.get(self.link+&#34;mount/model/add_point?ra_j2000_hours=%s&amp;dec_j2000_degs=%s&#34;%(RA.replace(&#34;:&#34;,&#34;%20&#34;),DEC.replace(&#34;:&#34;,&#34;%20&#34;)))
        timeout_sec = 30 #number of seconds before timing out the session. 
        timeout = time.time() + timeout_sec
        time.sleep(1)
        self.update()
        while self.MNT_slewing == &#34;true&#34;:
            print(&#39;Not on target yet - please wait&#39;)
            time.sleep(1)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The point at %s, %s (RA,DEC) has been added to the current pointing model&#39;%(RA,DEC))
        self.update()
        print(&#39;There are now %s points in the pointing model&#39;%(self.MNT_PointingModelPoints))
        return True
    

    
      
    def SavePointingModel(self,filename):
        &#34;&#34;&#34;
        The function saves the current pointing model, using the name provided by the user. 
        The pointing model is saved in &#34;Docuements/PlaneWave Instruments/PWI4/Mount&#34; on the local computer.
        The filename must be alphanumeric, but can also contain hyphen, &#34;-&#34;, and underscore &#34;_&#34;.
        The filename must end in &#34;.pxp&#34;.

    
        Example of command: 
            SavePointingModel(&#34;Feb_model.pxp&#34;)
        
        Args:
            The filename under which the pointing model is saved
        Returns:
            True when the pointing model is saved
            False if the filename is not alphanumeric
        &#34;&#34;&#34;
        #Test for ending
        try:
            pxp = filename.split(&#34;.&#34;)
            if pxp[1] != &#34;pxp&#34;:
                print(&#39;The filename needs to end with .pxp&#39;)
                return False
        except: 
            print(&#39;The filename must contain a &#34;.pxp&#34;&#39;)
            return False

        #testing for alphanumeric name
        copy = pxp[0]
        copy = copy.replace(&#34;-&#34;,&#34;&#34;)
        copy = copy.replace(&#34;_&#34;,&#34;&#34;)
        check = copy.isalnum()

        if check == False:
            print(&#39;Error:&#39;)
            print(&#39;The filename contains other characters than alphanumeric, &#34;-&#34; and &#34;_&#34;.&#39;)
            print(&#39;The model will not be saved.&#39;)
            return False
        
        print(&#39;The pointing model will be saved as %s momentarily - please wait.&#39; %(filename))
        cmd = requests.get(self.link+&#34;mount/model/save?filename=%s&#34;%(filename))
        time.sleep(1)
        self.update()
        time.sleep(1)
        if self.MNT_PointingModel == &#34;%s&#34;%(filename):
            print(&#39;Model saved. Location: Documents/PlaneWave Instruments/PWI4/Mount&#39;)
            return True
        else: 
            print(&#39;The pointing model was not saved correctly&#39;)
            return False
        
      
    
    
    def ClearPointingModel(self):
        &#34;&#34;&#34;
        This function deletes ALL the points in the current pointing model. 
        PLEASE BE CAREFUL WHEN USING THIS!

        Args:
            None

        Returns:
            True when points have been deleted
            False if the timeout session runs out 
        &#34;&#34;&#34;
        self.update()
        cmd = requests.get(self.link+&#34;mount/model/clear_points&#34;)
        self.update()
        time.sleep(1)
        timeout_sec = 10
        timeout = time.time() + timeout_sec
        while self.MNT_PointingModelPoints != &#34;0&#34;:
            print(&#39;Waiting for points to clear&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;This session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The pointing model has been cleared&#39;)
        return True




    def FansON(self):
        &#34;&#34;&#34;
        A function that turns the fans on in the telescope. 
        Firstly checks if the fans are already on. If not, then turns on fans.
        
        Args:
            None

        Returns: 
            True when fans are turned on.
            True if fans are already on.
            False if there is a timeout
        &#34;&#34;&#34;
        self.update()
        if self.FANS_state == &#39;True&#39;:
            print(&#39;The fans are already on&#39;)
            return True
        else:
            cmd = requests.get(self.link+&#39;?&amp;device=fans&amp;cmd=turnon&#39;)
            timeout_sec = 15 #number of seconds before timeout
            timeout = time.time() + timeout_sec
            while self.FANS_state == &#34;False&#34;:
                print(&#39;Waiting for fans to turn on - please wait&#39;)
                time.sleep(3)
                self.update()
                if time.time() &gt; timeout:
                    print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                    return False
        print(&#39;The fans are turned on&#39;)
        return True

    def FansOFF(self):
        &#34;&#34;&#34;
        A function that turns off the fans in the telescope. 
        If the fans are already off, then nothing happens. 
        Are the fans on, then a command is sent to turn the fans off.

        Args:
            None
        
        Returns: 
            True when fans are turned off
            True if fans are already off
            False is there is a timeout
        &#34;&#34;&#34;
        self.update()
        if self.FANS_state == &#39;False&#39;:
            print(&#39;The fans are already off.&#39;)
            return True
        else:
            cmd = requests.get(self.link+&#39;?&amp;device=fans&amp;cmd=turnoff&#39;)
            timeout_sec = 15 #Number of seconds before timeout
            timeout = time.time() + timeout_sec
            while self.FANS_state == &#34;True&#34;:
                print(&#39;Waiting for fans to turn off - please wait&#39;)
                time.sleep(2)
                self.update()
                if time.time() &gt; timeout:
                    print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                    return False
            print(&#39;The fans are turned off&#39;)
            return True
    

    def Rot_Move(self,position):
        &#34;&#34;&#34;
        A function that moves the rotator. The user provides the new position 
        in degrees, between 360 degrees and 0 degrees. 
        
        Args:
            New position to run rotator to. Must be between 0 and 360 degrees.
            
        Returns: 
            True when the rotator has finished moving
            False if the new position is above 360 degrees or below 0 degrees
            False if there is a timeout
        &#34;&#34;&#34;
        if position &gt; 360:
            print(&#39;The new position needs to be below 360 degrees.&#39;)
            return False
        
        if position &lt; 0: 
            print(&#39;The new position needs to be above 0 degrees.&#39;)
            return False
        
        print(&#39;The rotator will start moving momentarily - please wait&#39;)
        
        cmd = requests.get(self.link+&#34;rotator/goto_field?degs=%i&#34;%(position))
        time.sleep(2)
        self.update()
        timeout_sec = 180 #number of seconds before time-outting
        timeout = time.time() + timeout_sec
        while self.ROT_moving == &#34;true&#34;:
            self.update()
            print(&#39;The rotator is moving, current position is %s deg - please wait&#39;%(self.ROT_position))
            time.sleep(5)
            if time.time() &gt; timeout:
                print(&#39;There has been a timeout of %s seconds&#39;%(timeout_sec))
                print(&#39;The rotator position at timeout was %s deg&#39;%(self.ROT_position))
                return False
        print(&#39;The rotator has stopped and is at %s deg&#39;%(self.ROT_position))
        
        return True

        
        
    
    def RotSTOP(self):
        &#34;&#34;&#34;
        A function that stops all rotator movement. 
        This function is set on a separate thread along with the other stop-functions, to ensure they can always be called. 

        Args:
            None

        Returns:
            True when the rotator has stopped
            False if there is a timeout
        &#34;&#34;&#34;
        
        print(&#39;Trying to stop the rotator - please wait&#39;)
        cmd = requests.get(self.link+&#34;rotator/stop&#34;)
        time.sleep(1)
        self.update()
        timeout_sec = 15 #number of seconds before timeout
        timeout = time.time() + timeout_sec
        while self.ROT_moving == &#34;true&#34;:
            print(&#39;The rotator is still moving - please wait&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The rotator has stopped&#39;)
        return True
    
    
    # def Rot_StartHoming(self):
    #     &#34;&#34;&#34;
    #     A function that starts the rotator homing procedure. 
        
    #     Returns:
    #         True when the homing procedure is finished.
    #         False if there is a timeout.
    #     &#34;&#34;&#34;
    #     print(&#39;The rotator will start homing - please wait&#39;)
        
    #     cmd = requests.get(self.link+&#34;?&amp;device=rotator&amp;cmd=findhome&#34;)
        
    #     timeout_sec = 420 #number of seconds, 7 minutes
    #     timeout = time.time() + timeout_sec
    #     time.sleep(2)
    #     self.update()
    #     while self.ROT_homing == &#34;True&#34;:
    #         self.update()
    #         print(&#39;Rotator is homing, currently at %s deg - please wait&#39;%(self.ROT_position))
    #         time.sleep(2)
    #         if time.time() &gt; timeout:
    #             print(&#39;The session has timed out after %i seconds.&#39;%(timeout_sec))
    #             print(&#39;The rotator position at timeout was %s deg&#39;%(self.ROT_position))
    #             return False
    #     time.sleep(5)
    #     self.update()
    #     print(&#39;The rotator has finished homing - current position is %s deg&#39; %(self.ROT_position))
        
    #     return True
    
    def Rot_derotateStart(self):
        &#34;&#34;&#34;
        A function that enables de-rotation on the Alt-Azm mount.
        
        Args:
            None

        Returns:
            True when the de-rotation is enabled
            False if there is a timeout
        &#34;&#34;&#34;
        print(&#39;Enabling Alt-Azm field de-rotation - please wait&#39;)
        cmd = requests.get(self.link+&#34;rotator/enable&#34;)
        timeout_sec = 10 #number of seconds before time-out
        timeout = time.time()+ timeout_sec
        self.update()
        while self.ROT_AltAzDerotate == &#34;False&#34;:
            self.update()
            print(&#39;Derotation not enabled yet - please wait&#39;)
            time.sleep(1)
            if time.time() &gt; timeout:
                print(&#34;The session has timedout after %i seconds&#34;%(timeout_sec))
                return False
        print(&#39;Alt-Azm field de-rotation has been enabled.&#39;)
        return True
    
    
    def Rot_derotateStop(self):
        &#34;&#34;&#34;
        A function that disables de-rotation on the IFR90 focuser and rotator instrument.
        
        Args:
            None

        Returns:
            True when the de-rotation is disabled
            False if there is a timeout
        &#34;&#34;&#34;
        print(&#39;Disabling Alt-Azm field de-rotation - please wait&#39;)
        cmd = requests.get(self.link+&#34;rotator/disable&#34;)
        timeout_sec = 10 #number of seconds before timing out
        timeout = time.time() + timeout_sec
        self.update()
        while self.ROT_AltAzDerotate == &#34;True&#34;:
            print(&#39;Trying to disable Alt-Azm field de-rotation - please wait&#39;)
            self.update()
            time.sleep(1)
            if time.time() &gt; timeout:
                print(&#39;The session timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The Alt-Azm de-rotation has been disabled&#39;)
        return True
    
    def getRotatorDerotate(self):
        &#34;&#34;&#34;
        The function displays the current state of the derotation/field rotator on the IFR90 focuser/rotator unit. 
        
        Args:
            None

        Returns:
            A message of whether the deratote is ON or OFF
            False is there was an error
        &#34;&#34;&#34;
        
        self.update()
        if self.ROT_derotate_enabled == &#34;true&#34;:
            print(&#39;The Alt/Azm derotate is ON&#39;)
            reply = &#34;The Alt/Azm derotate is ON&#34;
            return reply
        
        if self.ROT_derotate_enabled == &#34;false&#34;:
            print(&#39;The Alt/Azm derotate is OFF&#39;)
            reply = &#34;The Alt/Azm deratote is OFF&#34;
            return reply
        else:
            print(&#39;There was an error&#39;)
            return False
            

    def setTargetRaDecJ2000(self,RA,DEC):
        &#34;&#34;&#34;
        A function to set coordinates for target in the J2000 Epoch. 
        The function MntMoveRaDecJ2000() can then take the values from self and 
        move the mount to the target. 
        
        Args:
            Right Ascension and Declination for target in J2000 Epoch in a string.
            Format should be:
                DD:MM:SS.SS
                HH:MM:SS.SS
        
        Example:
            setTargetRaDecJ2000(&#34;04:35:55.33&#34;,&#34;16:30:29.5&#34;,63.45, -188.94) #Aldebaran used for example
        
        Returns:
            True if the coordinates are set in self
            True if the coordinates are already set in self
            False if there was an error setting the coordinates
        &#34;&#34;&#34;
        #Check if the coordinates are already set
        try:
            if self.RAJ2000 == RA or self.DECJ2000 == DEC:
                print(&#39;The new coordinates are already set&#39;)
                return True
        except Exception as e:
            print(e)
    
        
        #save the new coordinates in self
        self.RAJ2000 = RA
        self.DECJ2000 = DEC

        ######################################################### proper motion stuff - can easily be commented out this way. 
        

        # #calculating the proper motion into RA and DEC. 
        # start_date = datetime.datetime(2000,1,1,0,0) #UTC time at the start of J2000.0 epoch
        # end_date = datetime.datetime.utcnow()
        # difference = end_date - start_date #The difference between now and J2000.0 start.
        # difference_yr = (difference.days + difference.seconds/86400.)/365.2425 #The difference in years between now and J2000.0 epoch.

        # #calculating the proper motion into Right Ascension and Declination
        # RA_pm * difference_yr *(1000) #now in arcseconds
        # DEC_pm * difference_yr *(1000) #now in arcseconds

        
        
        # #saves the proper motion in self
        # self.RAJ2000_pm = RA_pm
        # self.DECJ2000_pm = DEC_pm

        # if self.RAJ2000_pm !=RA_pm or self.DECJ2000_pm != DEC_pm:
        #     print(&#39;There was an error setting the proper motion&#39;)
        #     return False
        # ##############################################################

       
        #check if they are set correctly
        if self.RAJ2000 != RA or self.DECJ2000 != DEC:
            print(&#39;There was an error setting RA/DEC&#39;)
            return False
        

        print(&#39;The new coordinates have been set&#39;)
        return True
    
    def setTargetAltAzm(self,Alt,Azm):
        &#34;&#34;&#34;
        A function that sets the target coordinates for the Alt/Azm target.
        This function is used together with MntMoveAltAzm(), where the user
        first sets the coordinates with this function and then moves the 
        telescope with MntMoveAltAzm().
        
        The coordinates are set in self.
        
        Args:
            Altitude and Azimuth of the target as integers.
            
        Returns:
            True if the target coordinates are set correctly
            True if the new coordinates match the coordinates already set in self
            False if there was an issue setting the coordinates
            
        &#34;&#34;&#34;
        self.update()
        #Check if coordinates are already set
        try:
            if self.Alt == Alt and self.Azm == Azm:
                print(&#39;The new coordinates is already set&#39;)
                return True
        except Exception as e:
            print(e)
        
        #Set coordinates in self
        self.Alt = Alt
        self.Azm = Azm
        
        #check if they are corretly set in self
        if self.Alt != Alt or self.Azm != Azm:
            print(&#39;There was an error setting the new coordinates&#39;)
            return False
        
        print(&#39;The new Alt/Azm coordinates have been set&#39;)
        return True
    
    def setTargetRaDec(self,Ra,Dec):
        &#34;&#34;&#34;
        A function that set the coordinates for the target in topocentric 
        coordinates. 
        
        Args:
            Right Ascension and Declination in topocentric coordinates
            
            Format should be:
                DD:MM:SS.SS
                HH:MM:SS.SS
            Example:
                setTargetRaDec(&#34;11:32:59.79&#34;,&#34;-31:51:28.1&#34;)    
                
        Returns:
            True if the coordinates are set correctly
            True if the new coordinates match the existing coordinates
            False if there was an error setting the coordinates
        &#34;&#34;&#34;
        self.update()
        
        try:
            if self.RA == Ra or self.DEC == Dec:
                print(&#39;The new coordinates are already set&#39;)
                return True
        except Exception as e:
            print(e)
        
        self.RA = Ra
        self.DEC = Dec
        
        if self.RA != Ra or self.DEC != Dec:
            print(&#39;There was an error setting the new coordinates&#39;)
            return False
        print(&#39;The new coordinates have been set&#39;)
        return True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PW4.PWI4.AddPointToModel"><code class="name flex">
<span>def <span class="ident">AddPointToModel</span></span>(<span>self, RA, DEC)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that adds a point/target to current pointing model. It assigns the current telescope position (RA,DEC) to the input provided by
the user - which is also a RA and DEC in J2000 epoch. The input is checked for format errors before adding point to pointing model.
The telescope start tracking when this command is executed.</p>
<p>Example of command:
AddPointToModel("04:35:55.33","16:30:29.5") #Aldebaran's J2000.0 coordinates.</p>
<h2 id="args">Args</h2>
<p>RA and DEC in J2000 epoch to add to the current pointing model</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when point is added to the pointing model</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a format error in the input</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddPointToModel(self,RA,DEC):
    &#34;&#34;&#34;
    A function that adds a point/target to current pointing model. It assigns the current telescope position (RA,DEC) to the input provided by 
    the user - which is also a RA and DEC in J2000 epoch. The input is checked for format errors before adding point to pointing model.
    The telescope start tracking when this command is executed.
    
    Example of command:
        AddPointToModel(&#34;04:35:55.33&#34;,&#34;16:30:29.5&#34;) #Aldebaran&#39;s J2000.0 coordinates.

    Args:
        RA and DEC in J2000 epoch to add to the current pointing model

    Returns:
        True when point is added to the pointing model
        False if there is a format error in the input
        False if there is a timeout
    &#34;&#34;&#34;
    
    
    print(&#39;Adding point to model - please wait&#39;)
    check = self.checkFormatRaDec(RA,DEC)
    if check != 0:
        print(&#39;There was an error in the format of RA/DEC&#39;)
        print(&#39;No point will be added to the pointing model&#39;)
        return False

    cmd = requests.get(self.link+&#34;mount/model/add_point?ra_j2000_hours=%s&amp;dec_j2000_degs=%s&#34;%(RA.replace(&#34;:&#34;,&#34;%20&#34;),DEC.replace(&#34;:&#34;,&#34;%20&#34;)))
    timeout_sec = 30 #number of seconds before timing out the session. 
    timeout = time.time() + timeout_sec
    time.sleep(1)
    self.update()
    while self.MNT_slewing == &#34;true&#34;:
        print(&#39;Not on target yet - please wait&#39;)
        time.sleep(1)
        self.update()
        if time.time() &gt; timeout:
            print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
            return False
    print(&#39;The point at %s, %s (RA,DEC) has been added to the current pointing model&#39;%(RA,DEC))
    self.update()
    print(&#39;There are now %s points in the pointing model&#39;%(self.MNT_PointingModelPoints))
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.ClearPointingModel"><code class="name flex">
<span>def <span class="ident">ClearPointingModel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function deletes ALL the points in the current pointing model.
PLEASE BE CAREFUL WHEN USING THIS!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when points have been deleted</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the timeout session runs out</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ClearPointingModel(self):
    &#34;&#34;&#34;
    This function deletes ALL the points in the current pointing model. 
    PLEASE BE CAREFUL WHEN USING THIS!

    Args:
        None

    Returns:
        True when points have been deleted
        False if the timeout session runs out 
    &#34;&#34;&#34;
    self.update()
    cmd = requests.get(self.link+&#34;mount/model/clear_points&#34;)
    self.update()
    time.sleep(1)
    timeout_sec = 10
    timeout = time.time() + timeout_sec
    while self.MNT_PointingModelPoints != &#34;0&#34;:
        print(&#39;Waiting for points to clear&#39;)
        time.sleep(2)
        self.update()
        if time.time() &gt; timeout:
            print(&#39;This session has timed out after %i seconds&#39;%(timeout_sec))
            return False
    print(&#39;The pointing model has been cleared&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.ConnectFOC"><code class="name flex">
<span>def <span class="ident">ConnectFOC</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function to connect PWI to the focuser.
Please note that the rotator is also connected with the focuser
since they share the same port to PWI. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True if connection is complete</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if timeout occurs</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConnectFOC(self):
    &#34;&#34;&#34;
    A function to connect PWI to the focuser. 
    Please note that the rotator is also connected with the focuser
    since they share the same port to PWI. 

    Args:
        None
    
    Returns:
        True if connection is complete
        False if timeout occurs
    &#34;&#34;&#34;
    FOC = requests.get(self.link+&#34;focuser/enable&#34;)
    print(&#39;Trying to connect focuser - please wait&#39;)
    self.update()
    timeout_sec = 10 #Set the number of seconds before timeout.
    timeout = time.time() + timeout_sec
    while self.FOC_connection == &#34;false&#34;:
        print(&#39;Waiting for focuser to connect&#39;)
        self.update()
        time.sleep(1)
        if time.time() &gt; timeout:
            print(&#39;A timeout of %i sec has occured.&#39;%(timeout_sec))
            return False #stop if the timeout is reached!
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.ConnectMNT"><code class="name flex">
<span>def <span class="ident">ConnectMNT</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that connects PWI to the mount of the telescope and energizes
the motors (effectively turning them on).
Once the motors are energized, they CANNOT be moved by hand.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when connected and motors are energized</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConnectMNT(self):
    &#34;&#34;&#34;
    A function that connects PWI to the mount of the telescope and energizes 
    the motors (effectively turning them on). 
    Once the motors are energized, they CANNOT be moved by hand.  

    Args:
        None
    
    Returns:
        True when connected and motors are energized
        False if there is a timeout
    &#34;&#34;&#34;
    
    self.update()
    if self.MNT_connection == &#34;true&#34; and self.MNT_AzmMotor == &#34;true&#34; and self.MNT_AltMotor == &#34;true&#34;:
        print(&#39;The mount is already connected and energized.&#39;)
        return True
    cmd = requests.get(self.link+&#34;mount/connect&#34;)
    self.update()
    time.sleep(1)
    timeout_sec = 15 #Number of seconds before timeoutting
    timeout = time.time() + timeout_sec
    while self.MNT_connection == &#34;false&#34;:
        print(&#39;Trying to connect mount. Please wait&#39;)
        self.update()
        time.sleep(1)
        if time.time() &gt; timeout:
            print(&#39;The connection timed-out after %i seconds&#39;%(timeout_sec))
            return False
    print(&#39;Mount is connected. Energizing motors now - please wait&#39;)
    time.sleep(1)
    enableAzm = requests.get(self.link+&#34;mount/enable/axis=0&#34;)
    enableAlt = requests.get(self.link+&#34;mount/enable/axis=1&#34;)
    time.sleep(2)
    self.update()
    #I dont know if I can use the same timeout method here since it is in the same function?
    while self.MNT_AzmMotor == &#34;false&#34; and self.MNT_AltMotor == &#34;false&#34;:
        print(&#39;Energizing motors - please wait&#39;)
        time.sleep(1)
        self.update()
        if time.time() &gt; timeout + 30:
            print(&#39;There was a timeout during the energizing of the motors&#39;)
            return False
    print(&#39;Motors are energized! You can proceed.&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.DisconnectFOC"><code class="name flex">
<span>def <span class="ident">DisconnectFOC</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that disconnects the focuser from PWI.
Please note that the focuser and rotator are connected to PWI
via the same connection. A disconnect of the focuser would therefor
also disconnect the rotator.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True for finished disconnection</code></dt>
<dd>&nbsp;</dd>
<dt><code>False for timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DisconnectFOC(self):
    &#34;&#34;&#34;
    A function that disconnects the focuser from PWI. 
    Please note that the focuser and rotator are connected to PWI 
    via the same connection. A disconnect of the focuser would therefor
    also disconnect the rotator.
    
    Returns:
        True for finished disconnection
        False for timeout
    &#34;&#34;&#34;
    self.update()
    if self.FOC_connection == &#34;false&#34;:
        print(&#39;The focuser is already disconnected&#39;)
        return True

    cmd = requests.get(self.link+&#34;focuser/disable&#34;)
    self.update()
    timeout_sec = 20
    timeout = time.time() + timeout_sec
    while self.FOC_connection == &#34;true&#34;:
        print(&#39;Trying to disconnect focuser&#39;)
        self.update()
        time.sleep(1)
        if time.time() &gt; timeout:
            print(&#39;A timeout of %i has occured.&#39;%timeout_sec)
            print(&#39;There was error disconnecting the focuser&#39;)
            return False
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.DisconnectMNT"><code class="name flex">
<span>def <span class="ident">DisconnectMNT</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that disconnects the mount from PWI.
The opposite function - "ConnectMNT()" - connects the mount to PWI4.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when disconnection is finished</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout before disconnecting</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DisconnectMNT(self):
    &#34;&#34;&#34;
    A function that disconnects the mount from PWI.
    The opposite function - &#34;ConnectMNT()&#34; - connects the mount to PWI4.
    
    Returns:
        True when disconnection is finished
        False if there is a timeout before disconnecting
    &#34;&#34;&#34;
    self.update()
    if self.MNT_connection == &#34;false&#34;:
        print(&#39;The mount is already disconnected&#39;)
        return True
    #disableAzm = requests.get(self.link+&#34;mount/disable?axis=0&#34;)
    #disableAlt = requests.get(self.link+&#34;mount/disable?axis=1&#34;)
    time.sleep(2)
    cmd = requests.get(self.link+&#34;mount/disconnect&#34;)
    self.update()
    time.sleep(2)
    timeout_sec = 15 #set the number of seconds before timeout
    timeout = time.time()+timeout_sec
    while self.MNT_connection == &#34;true&#34;:
        print(&#39;Trying to disconnect mount. Please wait&#39;)
        self.update()
        time.sleep(2)
        if time.time() &gt; timeout:
            print(&#39;A timeout of %i sec has occured.&#39;%(timeout_sec))
            return False #stop if the timeout is reached!
    print(&#39;Mount disconnected!&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.FansOFF"><code class="name flex">
<span>def <span class="ident">FansOFF</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that turns off the fans in the telescope.
If the fans are already off, then nothing happens.
Are the fans on, then a command is sent to turn the fans off.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>True when fans are turned off
True if fans are already off
False is there is a timeout</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FansOFF(self):
    &#34;&#34;&#34;
    A function that turns off the fans in the telescope. 
    If the fans are already off, then nothing happens. 
    Are the fans on, then a command is sent to turn the fans off.

    Args:
        None
    
    Returns: 
        True when fans are turned off
        True if fans are already off
        False is there is a timeout
    &#34;&#34;&#34;
    self.update()
    if self.FANS_state == &#39;False&#39;:
        print(&#39;The fans are already off.&#39;)
        return True
    else:
        cmd = requests.get(self.link+&#39;?&amp;device=fans&amp;cmd=turnoff&#39;)
        timeout_sec = 15 #Number of seconds before timeout
        timeout = time.time() + timeout_sec
        while self.FANS_state == &#34;True&#34;:
            print(&#39;Waiting for fans to turn off - please wait&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                return False
        print(&#39;The fans are turned off&#39;)
        return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.FansON"><code class="name flex">
<span>def <span class="ident">FansON</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that turns the fans on in the telescope.
Firstly checks if the fans are already on. If not, then turns on fans.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>True when fans are turned on.
True if fans are already on.
False if there is a timeout</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FansON(self):
    &#34;&#34;&#34;
    A function that turns the fans on in the telescope. 
    Firstly checks if the fans are already on. If not, then turns on fans.
    
    Args:
        None

    Returns: 
        True when fans are turned on.
        True if fans are already on.
        False if there is a timeout
    &#34;&#34;&#34;
    self.update()
    if self.FANS_state == &#39;True&#39;:
        print(&#39;The fans are already on&#39;)
        return True
    else:
        cmd = requests.get(self.link+&#39;?&amp;device=fans&amp;cmd=turnon&#39;)
        timeout_sec = 15 #number of seconds before timeout
        timeout = time.time() + timeout_sec
        while self.FANS_state == &#34;False&#34;:
            print(&#39;Waiting for fans to turn on - please wait&#39;)
            time.sleep(3)
            self.update()
            if time.time() &gt; timeout:
                print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
                return False
    print(&#39;The fans are turned on&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.FocSTOP"><code class="name flex">
<span>def <span class="ident">FocSTOP</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stopping the focuser's movement.
This functions works, along with the other stop-functions, on a separate thread.
This ensures the function can always be called, by another terminal with the client running, even if another function is currently being executed. </p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when focuser has been stopped</code></dt>
<dd>&nbsp;</dd>
<dt><code>False when a timeout occurs</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FocSTOP(self):
    &#34;&#34;&#34;
    Stopping the focuser&#39;s movement. 
    This functions works, along with the other stop-functions, on a separate thread. 
    This ensures the function can always be called, by another terminal with the client running, even if another function is currently being executed. 
    
    Returns:
        True when focuser has been stopped
        False when a timeout occurs
    &#34;&#34;&#34;
    print(&#39;Stopping the focuser - please wait&#39;)
    cmd = requests.get(self.link+&#34;focuser/stop&#34;)
    timeout_sec = 20 #number of seconds before timeout
    timeout = time.time() + timeout_sec
    time.sleep(3)
    self.update()
    while self.FOC_moving == &#34;true&#34;:
        print(&#39;Focuser is still moving, now at %s microns, please wait&#39;%(self.FOC_pos))
        time.sleep(2)
        self.update()
        if time.time() &gt; timeout:
            print(&#39;A timeout of %i seconds occured.&#39;%(timeout_sec))
            return False
    print(&#34;The focuser has now stopped, at %s microns&#34;%(self.FOC_pos))
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.LoadPointingModel"><code class="name flex">
<span>def <span class="ident">LoadPointingModel</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>This function loads in a pointing model from Documents/PlaneWave Instruments/PWI4/Mount/
The filename has some restrictions:
1. only alphanumeric characters, underscore and hyphen
2. must end in ".pxp"
3. Must be in the path "Documents/PlaneWave Instruments/PWI4/Mount" on the computer
Example of command:
LoadPointingModel('Model1.pxp')</p>
<h2 id="args">Args</h2>
<p>Filename of pointing model you want to import</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when pointing model is loaded</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if name</code> of <code>new pointing model does not correspond to the filename</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LoadPointingModel(self,filename):
    &#34;&#34;&#34;
    This function loads in a pointing model from Documents/PlaneWave Instruments/PWI4/Mount/
    The filename has some restrictions:
        1. only alphanumeric characters, underscore and hyphen
        2. must end in &#34;.pxp&#34;
        3. Must be in the path &#34;Documents/PlaneWave Instruments/PWI4/Mount&#34; on the computer
    Example of command:
        LoadPointingModel(&#39;Model1.pxp&#39;)
        
    Args:
        Filename of pointing model you want to import
    Returns:
        True when pointing model is loaded
        False if name of new pointing model does not correspond to the filename           
    &#34;&#34;&#34;
    
    
    name, filetype = filename.split(&#39;.&#39;)
    if filetype != &#34;pxp&#34;:
        print(&#39;Error&#39;)
        print(&#39;The filetype must be .pxp!&#39;)
        return
    cmd = requests.get(self.link+&#34;mount/model/load?filename=%s&#34;%(filename))
    time.sleep(2)
    self.update()
    if self.MNT_PointingModel == filename:
        print(&#39;The poiting model %s has been loaded successfully.&#39;%(filename))
        return True
    else:
        print(&#39;There was an error loading in the pointing model.&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.MntMotorDisable"><code class="name flex">
<span>def <span class="ident">MntMotorDisable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that de-energizes the mount motors (Alt and Azm).
Essentially turning the motors off.
Once the motors are de-energized, you'll be able to move the mount by hand - but please be careful in doing so. </p>
<p>Args:<br>
None</p>
<p>Returns:
True when the motors are disabled
False if there is a timeout</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MntMotorDisable(self):
    &#34;&#34;&#34;
    A function that de-energizes the mount motors (Alt and Azm).
    Essentially turning the motors off. 
    Once the motors are de-energized, you&#39;ll be able to move the mount by hand - but please be careful in doing so. 
    
    Args:  
        None

    Returns: 
        True when the motors are disabled
        False if there is a timeout
    &#34;&#34;&#34;
    print(&#39;Sending command to de-energize motors - please wait&#39;)
    cmdAzm = requests.get(self.link+&#34;mount/disable?axis=0&#34;)
    cmdAlt = requests.get(self.link+&#34;mount/disable?axis=1&#34;)
    time.sleep(1)
    self.update()
    timeout_sec = 10 #number of seconds before timeout
    timeout = time.time() + timeout_sec
    while self.MNT_AltMotor == &#34;true&#34; and self.MNT_AzmMotor == &#34;true&#34;:
        print(&#34;Trying to energize motors - please wait&#34;)
        time.sleep(1)
        self.update()
        if time.time() &gt; timeout:
            print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
            return False
    print(&#39;The motors have been disabled.&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.MntMotorEnable"><code class="name flex">
<span>def <span class="ident">MntMotorEnable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that energizes the mount motors (Alt and Azm).
Essentially turning the motors on.
Once the motors are energized, they CANNOT be moved by hand.</p>
<p>Args:
None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when the motors are energized</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MntMotorEnable(self):
    &#34;&#34;&#34;
    A function that energizes the mount motors (Alt and Azm). 
    Essentially turning the motors on.
    Once the motors are energized, they CANNOT be moved by hand.

    Args: 
        None
    
    Returns:
        True when the motors are energized
        False if there is a timeout
    &#34;&#34;&#34;
    print(&#34;Sending command to energize motors - please wait&#34;)
    cmdAzm = requests.get(self.link+&#34;mount/enable?axis=0&#34;)
    cmdAlt = requests.get(self.link+&#34;mount/enable?axis=1&#34;)
    time.sleep(1)
    self.update()
    timeout_sec = 10 #number of seconds before timing out
    timeout = time.time() + timeout_sec
    while self.MNT_AltMotor == &#34;false&#34; and self.MNT_AzmMotor == &#34;false&#34;:
        self.update()
        print(&#39;Waiting for motors to energize - please wait&#39;)
        time.sleep(2)
        if time.time() &gt; timeout:
            print(&#34;The session has timed out after %i seconds&#34;%(timeout_sec))
            return False
    print(&#39;The motors have energized.&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.MntMotorReset"><code class="name flex">
<span>def <span class="ident">MntMotorReset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The function reset the motors. It calls two functions: Firstly the function
MntMotorDisable and then MntMotorEnable. The first function one de-energizes the motors,
while the second function energizes the motors. The mount motors have then been reset.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when resetting the mount is finished</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the resetting does not succed</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MntMotorReset(self):
    &#34;&#34;&#34;
    The function reset the motors. It calls two functions: Firstly the function
    MntMotorDisable and then MntMotorEnable. The first function one de-energizes the motors, 
    while the second function energizes the motors. The mount motors have then been reset.
    
    Returns:
        True when resetting the mount is finished
        False if the resetting does not succed
    
    &#34;&#34;&#34;
    print(&#39;Starting to reset mount motors&#39;)
    try:
        self.MntMotorDisable()
    except Exception as e:
        print(e)
    
    try:
        self.MntMotorEnable()
    except Exception as e:
        print(e)
    self.update()
    
    if self.MNT_AltMotor != &#34;true&#34; and self.MNT_AzmMotor != &#34;true&#34;:
        print(&#39;There was an error in the resetting of the motors&#39;)
        return False
    
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.MntMoveAltAzm"><code class="name flex">
<span>def <span class="ident">MntMoveAltAzm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function to move to the mount to an Altitude and Azimuth which is
first set with the function "setTargetAltAzm(Alt,Azm)". This means
you have to first set the Alt/Azm coordinates with "setTargetAltAzm(Alt,Azm)"
and then use this function to move the mount.</p>
<p>The input is first checked for format errors and if there are no errors,
and the target altitude is above the horizon limit - which is set to 15 degrees above horizon per version 0.0.1 -
gives the commmand to move the mount to the given coordinates. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when the mount has finished the movement and is on target and tracking</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is an error in the format</code> of <code>the input</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the target is below the horizon limit</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def MntMoveAltAzm(self):
        &#34;&#34;&#34;
        A function to move to the mount to an Altitude and Azimuth which is 
        first set with the function &#34;setTargetAltAzm(Alt,Azm)&#34;. This means
        you have to first set the Alt/Azm coordinates with &#34;setTargetAltAzm(Alt,Azm)&#34;
        and then use this function to move the mount.
        
        The input is first checked for format errors and if there are no errors,
        and the target altitude is above the horizon limit - which is set to 15 degrees above horizon per version 0.0.1 -
        gives the commmand to move the mount to the given coordinates. 

        Args:
            None
        
        Returns:
            True when the mount has finished the movement and is on target and tracking
            False if there is an error in the format of the input
            False if the target is below the horizon limit 
        &#34;&#34;&#34;
        self.update()
        #Loading in the altitude and azimuth
        Alt = self.Alt
        Azm = self.Azm
        
        #check function for Alt/azm
        errors = self.checkFormatAltAzm(Alt,Azm)
        if errors != 0:
            print(&#39;There was an error with the Alt/Azm format&#39;)
            print(&#39;The movement will NOT begin&#39;)
            return False
        horizon_limit = conf.NOVO_lower_limit #degrees above the horizon where the telescope cannot track below. SHOULD BE CHANGE ALSO IN PWI4 and in MntMoveRaDec and MntMoveRaDecJ2000
#        if Alt &gt; 90:
#            print(&#39;The altitude must be lower than 90 deg. The mount will NOT be moved&#39;)
#            return False
        if Alt &lt; horizon_limit:
            print(&#39;The altitude must be higher than %i degrees. The mount will NOT be moved&#39;%(horizon_limit))
            return False

        
        print(&#39;Starting movement in a moment - please wait&#39;)
        print(&#39;Starting position is at %.4f\xb0 %.4f\xb0 (Alt/Azm)&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
        cmd = requests.get(self.link+&#34;mount/goto_alt_az?alt_degs=%s&amp;az_degs=%s&#34;%(Alt,Azm))
        timeout_sec = 60 #number of seconds before timing out.
        timeout = time.time() + timeout_sec
        time.sleep(2)
        self.update()
        while self.MNT_slewing == &#34;true&#34;:
            print(&#39;Still moving the mount - please wait&#39;)
            self.update()
            time.sleep(2)
            if time.time() &gt; timeout:
                print(&#39;This session has timedout after %i seconds&#39;%(timeout_sec))
                print(&#39;The position at timeout was Alt: %s and Azm: %s&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
                return False
        print(&#39;The mount is on target and is tracking at %.3f\xb0,%.3f\xb0 (Alt/Azm)&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
        return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.MntMoveRaDec"><code class="name flex">
<span>def <span class="ident">MntMoveRaDec</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that moves the mount to the Right Ascension and Declination (RA and DEC).
The input is loaded in from the function "setTargetRaDec(Ra,Dec)" where the target
coordinates are set. This means you first set the target coordinates with
"setTargetRaDec(Ra,Dec)" and then move the mount with this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when the movement is finished and the mount is on target and tracking</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is an error in the format</code> of <code>the input</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the target is below horizon limit - which is set in the PWI4_config file</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MntMoveRaDec(self):
    &#34;&#34;&#34;
    A function that moves the mount to the Right Ascension and Declination (RA and DEC). 
    The input is loaded in from the function &#34;setTargetRaDec(Ra,Dec)&#34; where the target
    coordinates are set. This means you first set the target coordinates with 
    &#34;setTargetRaDec(Ra,Dec)&#34; and then move the mount with this function.

    Args:
        None
        
    Returns:
        True when the movement is finished and the mount is on target and tracking
        False if there is a timeout
        False if there is an error in the format of the input
        False if the target is below horizon limit - which is set in the PWI4_config file
    &#34;&#34;&#34;
    
    self.update()
    RA = self.RA
    DEC = self.DEC

    print(RA,DEC)
    
    print(&#39;Moving mount - please wait&#39;)
    check = self.checkFormatRaDec(RA,DEC)
    if check != 0:
        print(&#39;Error&#39;)
        print(&#39;There is an error in the format of the RA/DEC. Tracking will NOT be started.&#39;)
        return False
    
    star_init = SSCA.star_pos.__init__(self,site=conf.site)
    star_alt = SSCA.star_pos.star_alt(self,RA,DEC)
    star_azm = SSCA.star_pos.star_az(self,RA,DEC)
    horizon_limit = conf.NOVO_lower_limit #tracking limit. 
    alt_degree,_,_ = str(star_alt).split(&#34;:&#34;)
    print(alt_degree)
    
    if int(alt_degree) &gt; horizon_limit:
        print(&#39;Target is above horizon limit of %i degrees&#39;%(horizon_limit))
        print(&#39;The tracking will start momentarily - please wait&#39;)
        Ra_dec = RAconverter_HHtoDec(RA)
        Dec_dec = HMS2deg(ra = &#34;&#34;,dec =&#34;%s&#34;%(DEC))
        print(Ra_dec,Dec_dec)
        cmd = requests.get(self.link+&#34;mount/goto_ra_dec_apparent?ra_hours=%.5f&amp;dec_degs=%.5f&#34;%(float(Ra_dec[0]),float(Dec_dec)))
        timeout_sec = 60 #number of seconds before timing out
        timeout = time.time() + timeout_sec
        time.sleep(2)
        self.update()
        while self.MNT_slewing == &#34;true&#34;:
            print(&#39;Mount is still moving to target - please wait&#39;)
            time.sleep(2)
            self.update()
            if time.time() &gt; timeout: 
                print(&#39;The session has timed out after %i seconds&#39; %(timeout_sec))
                return False
        print(&#39;The telescope is on target and is tracking&#39;)
    
    elif int(alt_degree) &lt; horizon_limit: 
        print(&#39;The target is below the horizon limit of %i degrees&#39;%(horizon_limit))
        print(&#39;Tracking will NOT be started!&#39;)
        return False

    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.MntMoveRaDecJ2000"><code class="name flex">
<span>def <span class="ident">MntMoveRaDecJ2000</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that starts the observation of a target. The target coordinates
are passed through the function "setTargetRaDecJ2000(Ra,Dec)". This means
that the coordinates are first set with "setTargetRaDecJ2000(Ra,Dec)" and then
this function is used to move the mount.</p>
<p>The target coordinates are then checked for the format. If there are no errors,
the target is then checked if it on the night sky with the Observer at Mount Kent, Queensland Australia .</p>
<p>Per version 0.0.1:
The minimum elevation, called horizon_limit, above the horizon is set to 16 deg.
This is set in the config file "PWI4_config.py"</p>
<p>If target is above the minimum elevation, the mount will move to the target and track the target.</p>
<p>The mount will stay on target until otherwise told or until the target moves below the horizon limit.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when on target</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a error in the format</code> of <code>RA</code> or <code>DEC</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the target is below the minimum elevation above the horizon</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MntMoveRaDecJ2000(self):
    &#34;&#34;&#34;
    A function that starts the observation of a target. The target coordinates
    are passed through the function &#34;setTargetRaDecJ2000(Ra,Dec)&#34;. This means
    that the coordinates are first set with &#34;setTargetRaDecJ2000(Ra,Dec)&#34; and then
    this function is used to move the mount.
    
    The target coordinates are then checked for the format. If there are no errors, 
    the target is then checked if it on the night sky with the Observer at Mount Kent, Queensland Australia .
    
    Per version 0.0.1:
    The minimum elevation, called horizon_limit, above the horizon is set to 16 deg.
    This is set in the config file &#34;PWI4_config.py&#34;
    
    If target is above the minimum elevation, the mount will move to the target and track the target.
    
    The mount will stay on target until otherwise told or until the target moves below the horizon limit.

    Returns:
        True when on target
        False if there is a error in the format of RA or DEC
        False if the target is below the minimum elevation above the horizon
        False if there is a timeout
    &#34;&#34;&#34;
    self.update()
    #Load in the RA and DEC (in epoch J2000) from self
    RA = self.RAJ2000
    DEC = self.DECJ2000
    

    #################################################################################
    #This piece checks the format of the input is correct. The following
    #formats are accepted: HH:MM:SS.SS         
    format_err = self.checkFormatRaDec(RA,DEC)        
    if format_err != 0:
        print(&#34;Errors in input format. Tracking will NOT be started&#34;)
        return False
    
    
    ##################################################################################
    
    ##################################################################################
    #Now that the format is checked, the RA and DEC is sent to song_star_checker_AUTOTUNE.py (SSCA)
    #The SSCA script uses the ephem package to where on the sky the star is. 
    #The script then checks whether the coordinates are then correct. 
    # If they are correct, RA and DEC are then sent to SSCA to get the alt,azm
    # If alt is above horizon-limit, then it will proceed to track that target
    
    check = SSCA.coordinates.coordinate_check(self,RA,DEC)
    horizon_limit = conf.NOVO_lower_limit #the alt-limit in degrees for the telescope to track
    ###### PLEASE NOTE THAT PWI WILL TRACK THE TARGET TO THE LIMIT SET IN PWI4 (LOWER TRACKING LIMIT) 
    #I have now set it to 15 deg both here and in PWI, but if we want to change it in the future, we need to change it both places.
    if check == 0:
        star_init = SSCA.star_pos.__init__(self,site=conf.site) #sets the site for Mt. Kent
        star_alt = SSCA.star_pos.star_alt(self,RA,DEC) #uses the SSCA script to get alt
        star_azm = SSCA.star_pos.star_az(self,RA,DEC) #uses the SSCA script to get azm
        #print(&#39;Star alt, star azm&#39;)
        #print(star_alt,star_azm)
        if (str(star_alt)[1:2]) == &#39;:&#39;: #The return value of the altitude of the star, when the Alt is below 10, is i.e. 8 and not 08. The code crashed beforehand due to &#34;8:&#34; not being an integer
            if int(str(star_alt)[0:1]) &gt; horizon_limit:
                Ra_dec = RAconverter_HHtoDec(RA)
                Dec_dec = HMS2deg(ra = &#34;&#34;,dec =&#34;%s&#34;%(DEC))
                print(&#39;The target is above the horizon-limit of %i deg. The tracking will begin momentarily.&#39;%(horizon_limit))
                track = requests.get(self.link+&#34;mount/gotoradecj2000?ra_hours=%.4f&amp;dec_degs=%.5f&#34;%(float(Ra_dec[0]),float(Dec_dec)))
                print(track)
                timeout_sec = 60 #number of seconds before timeout
                timeout = time.time() + timeout_sec
                time.sleep(3)   
                self.update()
                while self.MNT_slewing == &#34;true&#34;:
                    print(&#39;Not on target yet, please wait&#39;) 
                    time.sleep(2)                   
                    self.update()
                    if time.time() &gt; timeout:
                        print(&#39;A timeout of %i seconds has occured&#39;%(timeout_sec))
                        return False
                print(&#39;The telescope is on target&#39;)
            elif int(str(star_alt)[0:1]) &lt; horizon_limit:
                print(&#39;The target is below the horizon-limit of %i deg&#39;%(horizon_limit))
                print(&#39;The tracking will NOT be started.&#39;)
                return False
            
            
        elif (str(star_alt)[2:3]) == &#39;:&#39;:    
            if int(str(star_alt)[0:2]) &gt; horizon_limit:
                Ra_dec = RAconverter_HHtoDec(RA)
                Dec_dec = HMS2deg(ra = &#34;&#34;,dec =&#34;%s&#34;%(DEC))
                print(&#39;The target is above the horizon-limit of %i deg. The tracking will begin momentarily.&#39;%(horizon_limit))
                track = requests.get(self.link+&#34;mount/goto_ra_dec_j2000?ra_hours=%.4f&amp;dec_degs=%.5f&#34;%(float(Ra_dec[0]),float(Dec_dec)))
                timeout_sec = 60 #number of seconds before timeout
                timeout = time.time() + timeout_sec
                time.sleep(3)   
                self.update()
                while self.MNT_slewing == &#34;true&#34;:
                    print(&#39;Not on target yet, please wait&#39;) 
                    time.sleep(2)                   
                    self.update()
                    if time.time() &gt; timeout:
                        print(&#39;A timeout of %i seconds has occured&#39;%(timeout_sec))
                        return False
                print(&#39;The telescope is on target&#39;)
            elif int(str(star_alt)[0:2]) &lt; horizon_limit:
                print(&#39;The target is below the horizon-limit of %i deg&#39;%(horizon_limit))
                print(&#39;The tracking will NOT be started.&#39;)
                return False
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.MountSTOP"><code class="name flex">
<span>def <span class="ident">MountSTOP</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function stops all mount movements when sent to PWI.
Please note that this function is called by the daemon on a different server (server2)
to make sure this stop function can be called even if other functions are running.</p>
<p>Example: The mount is moving to a new target, but needs to be stopped.
The "MountSTOP" command is sent, uses server2, which only checks for stop-functions,
and stops the mount.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when the mount is stopped</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MountSTOP(self):
    &#34;&#34;&#34;
    This function stops all mount movements when sent to PWI. 
    Please note that this function is called by the daemon on a different server (server2)
    to make sure this stop function can be called even if other functions are running.
    
    Example: The mount is moving to a new target, but needs to be stopped.
    The &#34;MountSTOP&#34; command is sent, uses server2, which only checks for stop-functions, 
    and stops the mount.
    
    Args:
        None

    Returns:
        True when the mount is stopped
        False if there is a timeout
    &#34;&#34;&#34;
    if self.MNT_tracking == &#39;false&#39;:
        print(&#39;Tracking is already off. The stop command will still be executed!&#39;)
        #A good idea? Otherwise, if there is something wrong and you can&#39;t stop the mount because of the if-statement.

    cmd = requests.get(self.link+&#39;mount/stop&#39;)
    timeout_sec = 15 #Number of seconds before timeout
    timeout = time.time()+timeout_sec
    while self.MNT_slewing == &#34;true&#34; and self.MNT_tracking == &#34;true&#34;:
        print(&#39;Waiting for mount to stop - please wait&#39;)
        time.sleep(2)
        self.update()
        if time.time() &gt; timeout:
            print(&#39;The session has timed-out after %i seconds&#39;%(timeout_sec))
            return False
    print(&#39;The mount has stopped&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.MoveFocuserPos"><code class="name flex">
<span>def <span class="ident">MoveFocuserPos</span></span>(<span>self, position)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that moves the focuser position. The position is given
is units of microns.
Moving the focuser to 10300 microns would be as:
MoveFocuserPos(10300) </p>
<p>Args:
The new position of the focuser given in microns</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when finished moving </code></dt>
<dd>&nbsp;</dd>
<dt><code>False if timeout occurs</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the end position does not match the target position within 5 microns</code> of <code>the target position</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MoveFocuserPos(self,position):
    &#34;&#34;&#34;
    A function that moves the focuser position. The position is given 
    is units of microns. 
    Moving the focuser to 10300 microns would be as:
        MoveFocuserPos(10300) 
    
    
    Args: 
        The new position of the focuser given in microns
        
        
    Returns:
        True when finished moving 
        False if timeout occurs
        False if the end position does not match the target position within 5 microns of the target position
    &#34;&#34;&#34;
    self.update()

    #Checks wheter the wanted position is already the current position. DOES NOT WORK FOR SOME REASON???
    if &#34;%s&#34;%(position) == self.FOC_pos:
        print(&#39;The new requested position is already the current position of the focuser. Nothing will happen.&#39;)
        return True

    if position &lt; 0:
        print(&#39;The position is less than 0 microns. The movement will NOT be executed&#39;)
        return False

    #Sends command to change position of focuser
    cmd=requests.get(self.link+&#34;focuser/goto?target=%i&#34;%(position))
    time.sleep(3)
    self.update()
    print(&#39;Starting to move focuser&#39;)
    timeout_sec = 30 #Number of seconds before a timeout
    timeout = time.time() + timeout_sec #setting timeout
    while self.FOC_moving == &#34;false&#34;:
        print(&#39;Focuser moving, now at %s microns&#39;%(self.FOC_pos))
        time.sleep(2)
        self.update()
        if time.time() &gt; timeout:
            print(&#39;A timeout of %i seconds occured.&#39;%(timeout_sec))
            return str(&#34;Error&#34;)
    self.update()
    if abs(self.FOC_pos - position) &lt; 5:  #Checks if the new position is close enough to target. Set to 5 microns initially.
        print(&#39;The focuser has stopped at: %s microns&#39;%(self.FOC_pos))
        return True
    else: 
        print(&#39;The focuser did not reach the target. The current position is %s microns&#39;%(self.FOC_pos))
        return False</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.RotSTOP"><code class="name flex">
<span>def <span class="ident">RotSTOP</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that stops all rotator movement.
This function is set on a separate thread along with the other stop-functions, to ensure they can always be called. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when the rotator has stopped</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RotSTOP(self):
    &#34;&#34;&#34;
    A function that stops all rotator movement. 
    This function is set on a separate thread along with the other stop-functions, to ensure they can always be called. 

    Args:
        None

    Returns:
        True when the rotator has stopped
        False if there is a timeout
    &#34;&#34;&#34;
    
    print(&#39;Trying to stop the rotator - please wait&#39;)
    cmd = requests.get(self.link+&#34;rotator/stop&#34;)
    time.sleep(1)
    self.update()
    timeout_sec = 15 #number of seconds before timeout
    timeout = time.time() + timeout_sec
    while self.ROT_moving == &#34;true&#34;:
        print(&#39;The rotator is still moving - please wait&#39;)
        time.sleep(2)
        self.update()
        if time.time() &gt; timeout:
            print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
            return False
    print(&#39;The rotator has stopped&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.Rot_Move"><code class="name flex">
<span>def <span class="ident">Rot_Move</span></span>(<span>self, position)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that moves the rotator. The user provides the new position
in degrees, between 360 degrees and 0 degrees. </p>
<h2 id="args">Args</h2>
<dl>
<dt>New position to run rotator to. Must be between 0 and 360 degrees.</dt>
<dt><strong><code>Returns</code></strong></dt>
<dd>True when the rotator has finished moving
False if the new position is above 360 degrees or below 0 degrees
False if there is a timeout</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Rot_Move(self,position):
    &#34;&#34;&#34;
    A function that moves the rotator. The user provides the new position 
    in degrees, between 360 degrees and 0 degrees. 
    
    Args:
        New position to run rotator to. Must be between 0 and 360 degrees.
        
    Returns: 
        True when the rotator has finished moving
        False if the new position is above 360 degrees or below 0 degrees
        False if there is a timeout
    &#34;&#34;&#34;
    if position &gt; 360:
        print(&#39;The new position needs to be below 360 degrees.&#39;)
        return False
    
    if position &lt; 0: 
        print(&#39;The new position needs to be above 0 degrees.&#39;)
        return False
    
    print(&#39;The rotator will start moving momentarily - please wait&#39;)
    
    cmd = requests.get(self.link+&#34;rotator/goto_field?degs=%i&#34;%(position))
    time.sleep(2)
    self.update()
    timeout_sec = 180 #number of seconds before time-outting
    timeout = time.time() + timeout_sec
    while self.ROT_moving == &#34;true&#34;:
        self.update()
        print(&#39;The rotator is moving, current position is %s deg - please wait&#39;%(self.ROT_position))
        time.sleep(5)
        if time.time() &gt; timeout:
            print(&#39;There has been a timeout of %s seconds&#39;%(timeout_sec))
            print(&#39;The rotator position at timeout was %s deg&#39;%(self.ROT_position))
            return False
    print(&#39;The rotator has stopped and is at %s deg&#39;%(self.ROT_position))
    
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.Rot_derotateStart"><code class="name flex">
<span>def <span class="ident">Rot_derotateStart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that enables de-rotation on the Alt-Azm mount.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when the de-rotation is enabled</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Rot_derotateStart(self):
    &#34;&#34;&#34;
    A function that enables de-rotation on the Alt-Azm mount.
    
    Args:
        None

    Returns:
        True when the de-rotation is enabled
        False if there is a timeout
    &#34;&#34;&#34;
    print(&#39;Enabling Alt-Azm field de-rotation - please wait&#39;)
    cmd = requests.get(self.link+&#34;rotator/enable&#34;)
    timeout_sec = 10 #number of seconds before time-out
    timeout = time.time()+ timeout_sec
    self.update()
    while self.ROT_AltAzDerotate == &#34;False&#34;:
        self.update()
        print(&#39;Derotation not enabled yet - please wait&#39;)
        time.sleep(1)
        if time.time() &gt; timeout:
            print(&#34;The session has timedout after %i seconds&#34;%(timeout_sec))
            return False
    print(&#39;Alt-Azm field de-rotation has been enabled.&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.Rot_derotateStop"><code class="name flex">
<span>def <span class="ident">Rot_derotateStop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that disables de-rotation on the IFR90 focuser and rotator instrument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when the de-rotation is disabled</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Rot_derotateStop(self):
    &#34;&#34;&#34;
    A function that disables de-rotation on the IFR90 focuser and rotator instrument.
    
    Args:
        None

    Returns:
        True when the de-rotation is disabled
        False if there is a timeout
    &#34;&#34;&#34;
    print(&#39;Disabling Alt-Azm field de-rotation - please wait&#39;)
    cmd = requests.get(self.link+&#34;rotator/disable&#34;)
    timeout_sec = 10 #number of seconds before timing out
    timeout = time.time() + timeout_sec
    self.update()
    while self.ROT_AltAzDerotate == &#34;True&#34;:
        print(&#39;Trying to disable Alt-Azm field de-rotation - please wait&#39;)
        self.update()
        time.sleep(1)
        if time.time() &gt; timeout:
            print(&#39;The session timed out after %i seconds&#39;%(timeout_sec))
            return False
    print(&#39;The Alt-Azm de-rotation has been disabled&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.SavePointingModel"><code class="name flex">
<span>def <span class="ident">SavePointingModel</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>The function saves the current pointing model, using the name provided by the user.
The pointing model is saved in "Docuements/PlaneWave Instruments/PWI4/Mount" on the local computer.
The filename must be alphanumeric, but can also contain hyphen, "-", and underscore "_".
The filename must end in ".pxp".</p>
<p>Example of command:
SavePointingModel("Feb_model.pxp")</p>
<h2 id="args">Args</h2>
<p>The filename under which the pointing model is saved</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when the pointing model is saved</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the filename is not alphanumeric</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SavePointingModel(self,filename):
    &#34;&#34;&#34;
    The function saves the current pointing model, using the name provided by the user. 
    The pointing model is saved in &#34;Docuements/PlaneWave Instruments/PWI4/Mount&#34; on the local computer.
    The filename must be alphanumeric, but can also contain hyphen, &#34;-&#34;, and underscore &#34;_&#34;.
    The filename must end in &#34;.pxp&#34;.


    Example of command: 
        SavePointingModel(&#34;Feb_model.pxp&#34;)
    
    Args:
        The filename under which the pointing model is saved
    Returns:
        True when the pointing model is saved
        False if the filename is not alphanumeric
    &#34;&#34;&#34;
    #Test for ending
    try:
        pxp = filename.split(&#34;.&#34;)
        if pxp[1] != &#34;pxp&#34;:
            print(&#39;The filename needs to end with .pxp&#39;)
            return False
    except: 
        print(&#39;The filename must contain a &#34;.pxp&#34;&#39;)
        return False

    #testing for alphanumeric name
    copy = pxp[0]
    copy = copy.replace(&#34;-&#34;,&#34;&#34;)
    copy = copy.replace(&#34;_&#34;,&#34;&#34;)
    check = copy.isalnum()

    if check == False:
        print(&#39;Error:&#39;)
        print(&#39;The filename contains other characters than alphanumeric, &#34;-&#34; and &#34;_&#34;.&#39;)
        print(&#39;The model will not be saved.&#39;)
        return False
    
    print(&#39;The pointing model will be saved as %s momentarily - please wait.&#39; %(filename))
    cmd = requests.get(self.link+&#34;mount/model/save?filename=%s&#34;%(filename))
    time.sleep(1)
    self.update()
    time.sleep(1)
    if self.MNT_PointingModel == &#34;%s&#34;%(filename):
        print(&#39;Model saved. Location: Documents/PlaneWave Instruments/PWI4/Mount&#39;)
        return True
    else: 
        print(&#39;The pointing model was not saved correctly&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.checkFormatAltAzm"><code class="name flex">
<span>def <span class="ident">checkFormatAltAzm</span></span>(<span>self, Alt, Azm)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that checks the format of the inputs which is the Altitude (Alt)
and Azimuth (Azm) of a target. </p>
<p>The unit of the inputs are in degrees.</p>
<p>The functions makes sure that the Alt is above 0 and below 90 degrees and
the Azm is between 0 degrees and 360 degrees. </p>
<h2 id="args">Args</h2>
<p>Altitude in degrees, Azimuth in degrees</p>
<h2 id="returns">Returns</h2>
<p>Number of errors in format. If #errors &gt; 0, then there is an issue with the format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkFormatAltAzm(self, Alt,Azm):
    &#34;&#34;&#34;
    A function that checks the format of the inputs which is the Altitude (Alt) 
    and Azimuth (Azm) of a target. 
    
    The unit of the inputs are in degrees.
    
    The functions makes sure that the Alt is above 0 and below 90 degrees and
    the Azm is between 0 degrees and 360 degrees. 
    
    Args:
        Altitude in degrees, Azimuth in degrees
        
    Returns:
        Number of errors in format. If #errors &gt; 0, then there is an issue with the format.
    
    &#34;&#34;&#34;
    
    
    error = 0
    if Alt &gt; 90:
        print(&#39;Error:&#39;)
        print(&#39;Altitude is in degrees and should be below 90 degrees&#39;)
        error += 1
    if Alt &lt; 0: 
        print(&#39;Error:&#39;)
        print(&#39;Altitude is in degrees and should above 0 degrees&#39;)
        error += 1
    if Azm &gt; 360:
        print(&#39;Error:&#39;)
        print(&#39;Azimuth is in degrees and should be below 360 degrees&#39;)
        error += 1
    if Azm &lt; 0:
        print(&#39;Error:&#39;)
        print(&#39;Azimuth is in degrees and should be above 0 degrees&#39;)
        error += 1
    
    return error</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.checkFormatArcsec"><code class="name flex">
<span>def <span class="ident">checkFormatArcsec</span></span>(<span>self, Arcsec)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that checks the format of arcseconds.
Per version 0.0.1, the function simply checks whether the input is above
60 or below 0. This may be changed in future versions.</p>
<h2 id="args">Args</h2>
<p>Input in arcseconds</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Number</code> of <code>errors in the format</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkFormatArcsec(self,Arcsec):
    &#34;&#34;&#34;
    A function that checks the format of arcseconds. 
    Per version 0.0.1, the function simply checks whether the input is above 
    60 or below 0. This may be changed in future versions.
    
    Args:
        Input in arcseconds

    Returns:
        Number of errors in the format  
    &#34;&#34;&#34;
    
    print(&#39;Checking format - please wait&#39;)
    error = 0 #number of errors:
    if float(Arcsec) &gt; 60.0:
        print(&#39;Error:&#39;)
        print(&#39;The number of arc seconds need to be below 60&#39;)
        error += 1
    if float(Arcsec) &lt; 0.0:
        print(&#39;Error:&#39;)
        print(&#39;The number of arc seconds should be above 0&#39;)
        error +=1
    return error</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.checkFormatRaDec"><code class="name flex">
<span>def <span class="ident">checkFormatRaDec</span></span>(<span>self, RA, DEC)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that checks the format of the input which is Right Ascension (RA)
and Declination (DEC) of a target. </p>
<p>The correct format for RA will be:
HH:MM:SS.SS</p>
<p>The correct format for DEC will be:
DD:MM:SS.SS</p>
<p>It is possible to parse a negative DEC. A correct example would be:
-15:50:06.50</p>
<h2 id="args">Args</h2>
<p>Right Ascension of target, Declination of target</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The number</code> of <code>errors in the format</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkFormatRaDec(self,RA,DEC):
    &#34;&#34;&#34;
    A function that checks the format of the input which is Right Ascension (RA) 
    and Declination (DEC) of a target. 
    
    
    The correct format for RA will be:
        HH:MM:SS.SS
    
    The correct format for DEC will be:
        DD:MM:SS.SS
    
    It is possible to parse a negative DEC. A correct example would be:
        -15:50:06.50
        
    Args:
        Right Ascension of target, Declination of target
    
    Returns:
        The number of errors in the format
    &#34;&#34;&#34;
    
    #Split up the input into 3 parts, not sure if this is a good idea to manually set it to max 3 parts. We&#39;ll see. 
    RA_hr,RA_mm,RA_ss = RA.split(&#34;:&#34;,2) 
    DEC_deg,DEC_mm,DEC_ss = DEC.split(&#34;:&#34;,2)
    print(RA_hr,RA_mm,RA_ss)
    print(DEC_deg,DEC_mm,DEC_ss)
    format_error = 0
    if len(RA_ss) == 5:
        if (RA_ss)[2] == &#34;:&#34;:
            print(&#39;Input error for RA. There is a &#34;:&#34; between the seconds input.&#39;)
            print(&#39;This should be a &#34;.&#34;&#39;)
            format_error += 1
    if len(DEC_ss) == 4:
        if (DEC_ss)[2] == &#34;:&#34;:
            print(&#39;Input error for DEC. There is a &#34;:&#34; between the seconds input.&#39;)
            print(&#39;This should be a &#34;.&#34;&#39;)
            format_error += 1        
    return format_error</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getALL"><code class="name flex">
<span>def <span class="ident">getALL</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints all data that is available from PWI4 is a list. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>A list of parameters and their values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getALL(self):
    &#34;&#34;&#34;
    Prints all data that is available from PWI4 is a list. 
    
    Args:
        None

    Returns: 
        A list of parameters and their values
    &#34;&#34;&#34;
    self.update()
    ALL=self.status
    print(ALL)
    return ALL</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getDEC2000"><code class="name flex">
<span>def <span class="ident">getDEC2000</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that prints the current Declination (DEC) in the J2000 epoch of the mount/telescope.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DEC_J2000 in the format DD:MM:SS</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDEC2000(self):
    &#34;&#34;&#34;
    A function that prints the current Declination (DEC) in the J2000 epoch of the mount/telescope.
    
    Args:
        None

    Returns:
        DEC_J2000 in the format DD:MM:SS
    &#34;&#34;&#34;
    
    self.update()
    DEC = self.MNT_Dec2000
    DEC_hour = DecConverter_DecitoDD(float(DEC))
    return DEC_hour</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getFOC_CONNECT"><code class="name flex">
<span>def <span class="ident">getFOC_CONNECT</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that checks the connection between PWI and the focuser.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True if the focuser is connected to <a title="PW4.PWI4" href="#PW4.PWI4">PWI4</a></code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the focuser is not connected to <a title="PW4.PWI4" href="#PW4.PWI4">PWI4</a></code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the focuser connection could not be reached</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFOC_CONNECT(self):
    &#34;&#34;&#34;
    A function that checks the connection between PWI and the focuser.

    Args:
        None
    
    Returns:
        True if the focuser is connected to PWI4
        False if the focuser is not connected to PWI4
        False if the focuser connection could not be reached
    &#34;&#34;&#34;
    self.update()
    
    if self.FOC_connection == &#34;true&#34;:
        print(&#34;Focuser is connected&#34;)
        return True
    if self.FOC_connection == &#34;false&#34;:
        print(&#34;Focuser is NOT connected&#34;)
        return False
    else:
        print(&#34;ERROR: Connection to focuser is not reachable&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getFocuserPos"><code class="name flex">
<span>def <span class="ident">getFocuserPos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that prints the current position of the focuser in the telscope.
The units of the position is in microns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The position</code> of <code>the focuser in microns if the focuser is connected</code></dt>
<dd>&nbsp;</dd>
<dt><code>If the focuser is not connected, a reply is sent about the focuser not being connected</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFocuserPos(self):
    &#34;&#34;&#34;
    A function that prints the current position of the focuser in the telscope. 
    The units of the position is in microns.
    
    Args:
        None

    Returns:
        The position of the focuser in microns if the focuser is connected
        If the focuser is not connected, a reply is sent about the focuser not being connected
    &#34;&#34;&#34;
    self.update()
    if self.FOC_connection == &#34;true&#34;:
        print(&#39;The current position of the focuser is %s microns&#39;%(self.FOC_pos))
        reply = &#34;The current position of the focuser is %s microns&#34;%(self.FOC_pos)
        return reply
    else:
        print(&#39;The focuser is not connected to PWI4. Please use .ConnectFOC() to connect the focuser to PWI4.&#39;)
        reply = &#39;The focuser is not connected to PWI4. Please use .ConnectFOC() to connect the focuser to PWI4.&#39;
        return reply</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getIsTrackingOn"><code class="name flex">
<span>def <span class="ident">getIsTrackingOn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that checks if the telescope is tracking a target.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when the tracking is on</code></dt>
<dd>&nbsp;</dd>
<dt><code>False when the tracking is off</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getIsTrackingOn(self):
    &#34;&#34;&#34;
    A function that checks if the telescope is tracking a target.

    Args:
        None
    
    Returns:
        True when the tracking is on
        False when the tracking is off
    &#34;&#34;&#34;
    self.update()
   
    if  self.MNT_tracking == &#34;true&#34;:
        print(&#34;Tracking is ON.&#34;)
        return True 
    else:
        print(&#34;Tracking is OFF.&#34;)
        return False </code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getMNT_CONNECT"><code class="name flex">
<span>def <span class="ident">getMNT_CONNECT</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that checks the connection between PWI and the mount of telescope.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True if the mount is connected</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the mount is not connected</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if the mount state is neither connected nor disconnected</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMNT_CONNECT(self):
    &#34;&#34;&#34;
    A function that checks the connection between PWI and the mount of telescope.
    
    Args:
        None

    Returns:
        True if the mount is connected
        False if the mount is not connected
        False if the mount state is neither connected nor disconnected
    &#34;&#34;&#34;
    self.update()
    if self.MNT_connection == &#34;true&#34;:
        print(&#34;Mount is connected&#34;)
        return True
    if self.MNT_connection == &#34;false&#34;:
        print(&#34;Mount is NOT connected&#34;)
        return False
    else:
        print(&#34;ERROR: Mount state unable to be read!&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getRA2000"><code class="name flex">
<span>def <span class="ident">getRA2000</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that prints the current Right Ascension (RA) in the J2000 epoch of the mount/telescope.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>RA_J2000 in the format HH:MM:SS</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRA2000(self):
    &#34;&#34;&#34;
    A function that prints the current Right Ascension (RA) in the J2000 epoch of the mount/telescope.
    
    Args:
        None

    Returns:
        RA_J2000 in the format HH:MM:SS
    &#34;&#34;&#34;
    self.update()
    RA = self.MNT_Ra2000

    RA_hour = RAconverter_DectoHH(float(RA))
    return RA_hour</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getROT_CONNECT"><code class="name flex">
<span>def <span class="ident">getROT_CONNECT</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A functions that checks the connection between PWI and the rotator.
Please note that the focuser and rotator are connected such that
the focuser and rotator share the same connection to PWI.
So if the rotator is not connected, then the focuser won't bet connected either. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when the rotator is connected to <a title="PW4.PWI4" href="#PW4.PWI4">PWI4</a></code></dt>
<dd>&nbsp;</dd>
<dt><code>False when the rotator is not connected to <a title="PW4.PWI4" href="#PW4.PWI4">PWI4</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getROT_CONNECT(self):
    &#34;&#34;&#34;
    A functions that checks the connection between PWI and the rotator. 
    Please note that the focuser and rotator are connected such that
    the focuser and rotator share the same connection to PWI. 
    So if the rotator is not connected, then the focuser won&#39;t bet connected either. 

    Args:
        None
    
    Returns:
        True when the rotator is connected to PWI4
        False when the rotator is not connected to PWI4
    &#34;&#34;&#34;

    self.update()
    
    if self.ROT_connection == &#34;true&#34;:
        print(&#34;Rotator is connected&#34;)
        return self.ROT_connection
    if self.ROT_connection == &#34;false&#34;:
        print(&#34;Rotator is not connected&#34;)
        return False
    else:
        print(&#34;ERROR: Rotator connection is not reachable.&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getRotatorDerotate"><code class="name flex">
<span>def <span class="ident">getRotatorDerotate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The function displays the current state of the derotation/field rotator on the IFR90 focuser/rotator unit. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A message</code> of <code>whether the deratote is ON</code> or <code>OFF</code></dt>
<dd>&nbsp;</dd>
<dt><code>False is there was an error</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRotatorDerotate(self):
    &#34;&#34;&#34;
    The function displays the current state of the derotation/field rotator on the IFR90 focuser/rotator unit. 
    
    Args:
        None

    Returns:
        A message of whether the deratote is ON or OFF
        False is there was an error
    &#34;&#34;&#34;
    
    self.update()
    if self.ROT_derotate_enabled == &#34;true&#34;:
        print(&#39;The Alt/Azm derotate is ON&#39;)
        reply = &#34;The Alt/Azm derotate is ON&#34;
        return reply
    
    if self.ROT_derotate_enabled == &#34;false&#34;:
        print(&#39;The Alt/Azm derotate is OFF&#39;)
        reply = &#34;The Alt/Azm deratote is OFF&#34;
        return reply
    else:
        print(&#39;There was an error&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getRotatorPos"><code class="name flex">
<span>def <span class="ident">getRotatorPos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that prints the current position of the rotator.
The units of the position of the rotator is in degrees. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The current position</code> of <code>the rotator in degrees</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRotatorPos(self):
    &#34;&#34;&#34;
    A function that prints the current position of the rotator.
    The units of the position of the rotator is in degrees. 

    Args:
        None
    
    Returns:
        The current position of the rotator in degrees
    &#34;&#34;&#34;
    self.update()
    if self.ROT_connection == &#34;true&#34;:
        print(&#39;The current position of the rotator is %s degrees&#39;%(self.ROT_pos))
        reply = &#39;The current position of the rotator is %s degrees&#39;%(self.ROT_pos)
        return reply
    else:
        print(&#34;The rotator is not connected to PWI. Try the command: ConnectFOC()  &#34;)
        reply = &#39;The rotator is not connected to PWI. Try the command: ConnectFOC() &#39;
        return reply</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getStatus"><code class="name flex">
<span>def <span class="ident">getStatus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a status message with the current RA and DEC in J2000 epoch, the
current UTC time. The message also gives a message whehter the telescope
is moving and/or tracking. Finally it prints whether the mount, focuser and rotator is
connected to the PWI. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The status message</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getStatus(self):
    &#34;&#34;&#34;
    Prints a status message with the current RA and DEC in J2000 epoch, the 
    current UTC time. The message also gives a message whehter the telescope 
    is moving and/or tracking. Finally it prints whether the mount, focuser and rotator is
    connected to the PWI. 
    
    Args:
        None

    Returns:
        The status message
    
    &#34;&#34;&#34;
    self.update()
    RA = self.MNT_Ra2000
    DEC = self.MNT_Dec2000
    Alt = self.MNT_Alt
    Azm = self.MNT_Azm
    Moving = self.MNT_slewing
    Mnt = self.MNT_connection
    Foc = self.FOC_connection
    tracking = self.MNT_tracking
    Rot = self.ROT_connection
    
    
    reply = &#34;The telescope is pointed at RA: %s, DEC:%s (J2000) / Alt: %.4f, Azm: %.4f. \n&#34; %(RA,DEC,float(Alt),float(Azm))
    print(&#39;The telescope is pointed at RA: %s, DEC:%s (J2000) / Alt: %.4f, Azm: %.4f.&#39; %(RA,DEC,float(Alt),float(Azm)))

    if Moving == &#34;False&#34;:
        print(&#39;The telescope is not moving.&#39;)
        reply += &#39;The telescope is not moving.\n&#39;
    elif Moving == &#34;True&#34;:
        print(&#39;The telescope is moving.&#39;)
        reply += &#39;The telescope is moving.\n&#39;
        
    if tracking == &#34;True&#34;:
        print(&#39;The telescope is tracking.&#39;)
        reply += &#39;The telescope is tracking \n&#39;
    elif tracking == &#34;False&#34;:
        print(&#39;The telescope is NOT tracking.&#39;)
        reply += &#39;The telescope is NOT tracking \n&#39;
   
    
    print(&#39;Connections: \n&#39;)
    reply += &#39;Connections: \n&#39;
    if Mnt == &#34;true&#34;:
        print(&#39;The mount is connected to PWI&#39;)
        reply += &#39;The mount is connected to PWI \n&#39;
    elif Mnt == &#34;false&#34;:
        print(&#39;The mount is NOT connected to PWI&#39;)
        print(&#39;You should try connecting the mount with PWI using the command: .ConnectMNT()\n&#39;)
        reply += &#39;The mount is NOT connected to PWI \n&#39; 
        reply += &#39;You should try connecting the mount with PWI using the command: .ConnectMNT() \n&#39;
        
        
    if Foc == &#34;true&#34;:
        print(&#39;The focuser is connected to PWI&#39;)
        reply += &#39;The focuser is connected to PWI \n&#39;
    elif Foc == &#34;false&#34;:
        print(&#39;The focuser is NOT connected to PWI&#39;)
        print(&#39;You should try connecting the focuser with the command: .ConnectFOC()\n&#39;)
        reply += &#39;The focuser is NOT connected to PWI\n&#39;
        reply += &#39;You should try connecting the focuser with the command: .ConnectFOC() \n&#39;
        
    if Rot == &#34;true&#34;:
        print(&#39;The rotator is connected to PWI&#39;)
        reply += &#39;The rotator is connected to PWI\n&#39;
    elif Rot == &#34;false&#34;:
        print(&#39;The rotator is NOT connected to PWI&#39;)
        print(&#39;The rotator and focuser is linked in their connection.&#39;)
        print(&#39;You should maybe try to reconnect the focuser and theirby reconnect the rotator wit----h the functions: .DisconnectFOC() and .ConnectFOC()\n&#39;)
        reply += &#39;The rotator is NOT connected to PWI \n&#39;
        reply += &#39;The rotator and focuser is linked in their connection. \n&#39;
        reply += &#39;You should maybe try to reconnect the focuser and theirby reconnect the rotator with the functions: .DisconnectFOC() and .ConnectFOC() \n&#39;
    
    return reply</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getTemps"><code class="name flex">
<span>def <span class="ident">getTemps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the temperature of the primary mirror, the ambient temperature,
the secondary mirror, the backplate and the M3.
The unit of temperature is Celcius.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Message with temperature</code> of <code>the primary mirror, the ambient temperature, </code></dt>
<dd>&nbsp;</dd>
<dt><code>the secondary mirror, the backplate and the M3 (in this order)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTemps(self):
    &#34;&#34;&#34;
    Prints the temperature of the primary mirror, the ambient temperature, 
    the secondary mirror, the backplate and the M3. 
    The unit of temperature is Celcius.
    
    Returns:
        Message with temperature of the primary mirror, the ambient temperature, 
    the secondary mirror, the backplate and the M3 (in this order)
    &#34;&#34;&#34;
    
    
    self.update()
    Temp_PRI = self.TEMP_pri
    Temp_AMB = self.TEMP_amb
    Temp_SEC = self.TEMP_sec
    Temp_BPL = self.TEMP_backp
    Temp_M3 = self.TEMP_m3
    
    reply = &#34;&#34;
    
    #For the logging
    print(&#34;Temperature of primary:&#34;,Temp_PRI + &#34; C&#34;) 
    print(&#34;Temperature of ambient:&#34;,Temp_AMB + &#34; C&#34;) 
    print(&#34;Temperature of secondary:&#34;,Temp_SEC + &#34; C&#34;) 
    print(&#34;Temperature of backplate:&#34;,Temp_BPL + &#34; C&#34;)
    print(&#34;Temperature of M3:&#34;,Temp_M3 + &#34; C&#34;) 
    
    #for the client
    reply += &#34;Temperature of primary: %s C \n&#34;%(Temp_PRI)
    reply += &#34;Temperature of ambient: %s C\n&#34;%(Temp_AMB)
    reply += &#34;Temperature of secondary: %s C\n&#34;%(Temp_SEC)
    reply += &#34;Temperature of backplate: %s C\n&#34;%(Temp_BPL)
    reply += &#34;Temperature of M3: %s C\n&#34;%(Temp_M3)
    
    return reply</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.getTrackingRMSError"><code class="name flex">
<span>def <span class="ident">getTrackingRMSError</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that returns the Root Mean Square (RMS) of the tracking error for both the Alt and Azm motor. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reply message witht the RMS error</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTrackingRMSError(self):
    &#34;&#34;&#34;
    A function that returns the Root Mean Square (RMS) of the tracking error for both the Alt and Azm motor. 
    
    Args:
        None
    Returns:
        Reply message witht the RMS error
    &#34;&#34;&#34;
    
    self.update()
    print(&#39;The RMS error on the Alt pointing is %.3f arcseconds&#39;%(float(self.MNT_AltRMSErrorArcsec)))
    print(&#39;The RMS error on the Azm pointing is %.3f arcseconds&#39;%(float(self.MNT_AzmRMSErrorArcsec)))

    reply = &#39;The RMS error on the Alt pointing is %.3f arcseconds \n&#39;%(float(self.MNT_AltRMSErrorArcsec))
    reply += &#39;The RMS error on the Azm pointing is %.3f arcseconds&#39;%(float(self.MNT_AzmRMSErrorArcsec))
    return reply</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.parkMount"><code class="name flex">
<span>def <span class="ident">parkMount</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that parks the mount to a parking position. The mount moves to the
parking position, tracks the position of the parking position for a very short amount of time
and then stops tracking the parking position, thereby stopping the mount at the parking position.</p>
<p>The parking position is set in the PW4_config.py file.</p>
<p>The function uses the function "stopTracking" for stopping the tracking once the mount is on target.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when parking the mount is done </code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there was a timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parkMount(self):
    &#34;&#34;&#34;
    A function that parks the mount to a parking position. The mount moves to the 
    parking position, tracks the position of the parking position for a very short amount of time
    and then stops tracking the parking position, thereby stopping the mount at the parking position.

    The parking position is set in the PW4_config.py file.
    
    The function uses the function &#34;stopTracking&#34; for stopping the tracking once the mount is on target.

    Args:
        None
    
    Returns:
        True when parking the mount is done 
        False if there was a timeout 
    &#34;&#34;&#34;
    park_alt = conf.park_alt # the altitude in deg where the telescope will be parked 
    park_azm = conf.park_azm # the azimuth in deg where the telescope will be parked
    print(&#39;The mount will be parked to the position %i\xb0, %i\xb0 (Alt,Azm)&#39;%(park_alt,park_azm))
    park = requests.get(self.link+&#34;mount/goto_alt_az?alt_degs=%s&amp;az_degs=%s&#34;%(park_alt,park_azm))
    timeout_sec = 60 #number of sec before timeout
    timeout = time.time() + timeout_sec
    time.sleep(3)
    self.update()
    while self.MNT_slewing == &#34;true&#34;:
        print(&#39;Mount still moving - please wait&#39;)
        time.sleep(2)
        self.update()
        if time.time() &gt; timeout:
            print(&#39;The session has timed out after %i seconds&#39; %(timeout_sec))
            return False
    time.sleep(2)
    self.stopTracking() #Stops the tracking of the parking point
    
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.setTargetAltAzm"><code class="name flex">
<span>def <span class="ident">setTargetAltAzm</span></span>(<span>self, Alt, Azm)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that sets the target coordinates for the Alt/Azm target.
This function is used together with MntMoveAltAzm(), where the user
first sets the coordinates with this function and then moves the
telescope with MntMoveAltAzm().</p>
<p>The coordinates are set in self.</p>
<h2 id="args">Args</h2>
<p>Altitude and Azimuth of the target as integers.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True if the target coordinates are set correctly</code></dt>
<dd>&nbsp;</dd>
<dt><code>True if the new coordinates match the coordinates already set in self</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there was an issue setting the coordinates</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTargetAltAzm(self,Alt,Azm):
    &#34;&#34;&#34;
    A function that sets the target coordinates for the Alt/Azm target.
    This function is used together with MntMoveAltAzm(), where the user
    first sets the coordinates with this function and then moves the 
    telescope with MntMoveAltAzm().
    
    The coordinates are set in self.
    
    Args:
        Altitude and Azimuth of the target as integers.
        
    Returns:
        True if the target coordinates are set correctly
        True if the new coordinates match the coordinates already set in self
        False if there was an issue setting the coordinates
        
    &#34;&#34;&#34;
    self.update()
    #Check if coordinates are already set
    try:
        if self.Alt == Alt and self.Azm == Azm:
            print(&#39;The new coordinates is already set&#39;)
            return True
    except Exception as e:
        print(e)
    
    #Set coordinates in self
    self.Alt = Alt
    self.Azm = Azm
    
    #check if they are corretly set in self
    if self.Alt != Alt or self.Azm != Azm:
        print(&#39;There was an error setting the new coordinates&#39;)
        return False
    
    print(&#39;The new Alt/Azm coordinates have been set&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.setTargetRaDec"><code class="name flex">
<span>def <span class="ident">setTargetRaDec</span></span>(<span>self, Ra, Dec)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that set the coordinates for the target in topocentric
coordinates. </p>
<h2 id="args">Args</h2>
<p>Right Ascension and Declination in topocentric coordinates</p>
<p>Format should be:
DD:MM:SS.SS
HH:MM:SS.SS
Example:
setTargetRaDec("11:32:59.79","-31:51:28.1")
</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True if the coordinates are set correctly</code></dt>
<dd>&nbsp;</dd>
<dt><code>True if the new coordinates match the existing coordinates</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there was an error setting the coordinates</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTargetRaDec(self,Ra,Dec):
    &#34;&#34;&#34;
    A function that set the coordinates for the target in topocentric 
    coordinates. 
    
    Args:
        Right Ascension and Declination in topocentric coordinates
        
        Format should be:
            DD:MM:SS.SS
            HH:MM:SS.SS
        Example:
            setTargetRaDec(&#34;11:32:59.79&#34;,&#34;-31:51:28.1&#34;)    
            
    Returns:
        True if the coordinates are set correctly
        True if the new coordinates match the existing coordinates
        False if there was an error setting the coordinates
    &#34;&#34;&#34;
    self.update()
    
    try:
        if self.RA == Ra or self.DEC == Dec:
            print(&#39;The new coordinates are already set&#39;)
            return True
    except Exception as e:
        print(e)
    
    self.RA = Ra
    self.DEC = Dec
    
    if self.RA != Ra or self.DEC != Dec:
        print(&#39;There was an error setting the new coordinates&#39;)
        return False
    print(&#39;The new coordinates have been set&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.setTargetRaDecJ2000"><code class="name flex">
<span>def <span class="ident">setTargetRaDecJ2000</span></span>(<span>self, RA, DEC)</span>
</code></dt>
<dd>
<div class="desc"><p>A function to set coordinates for target in the J2000 Epoch.
The function MntMoveRaDecJ2000() can then take the values from self and
move the mount to the target. </p>
<h2 id="args">Args</h2>
<p>Right Ascension and Declination for target in J2000 Epoch in a string.
Format should be:
DD:MM:SS.SS
HH:MM:SS.SS</p>
<h2 id="example">Example</h2>
<p>setTargetRaDecJ2000("04:35:55.33","16:30:29.5",63.45, -188.94) #Aldebaran used for example</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True if the coordinates are set in self</code></dt>
<dd>&nbsp;</dd>
<dt><code>True if the coordinates are already set in self</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there was an error setting the coordinates</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTargetRaDecJ2000(self,RA,DEC):
    &#34;&#34;&#34;
    A function to set coordinates for target in the J2000 Epoch. 
    The function MntMoveRaDecJ2000() can then take the values from self and 
    move the mount to the target. 
    
    Args:
        Right Ascension and Declination for target in J2000 Epoch in a string.
        Format should be:
            DD:MM:SS.SS
            HH:MM:SS.SS
    
    Example:
        setTargetRaDecJ2000(&#34;04:35:55.33&#34;,&#34;16:30:29.5&#34;,63.45, -188.94) #Aldebaran used for example
    
    Returns:
        True if the coordinates are set in self
        True if the coordinates are already set in self
        False if there was an error setting the coordinates
    &#34;&#34;&#34;
    #Check if the coordinates are already set
    try:
        if self.RAJ2000 == RA or self.DECJ2000 == DEC:
            print(&#39;The new coordinates are already set&#39;)
            return True
    except Exception as e:
        print(e)

    
    #save the new coordinates in self
    self.RAJ2000 = RA
    self.DECJ2000 = DEC

    ######################################################### proper motion stuff - can easily be commented out this way. 
    

    # #calculating the proper motion into RA and DEC. 
    # start_date = datetime.datetime(2000,1,1,0,0) #UTC time at the start of J2000.0 epoch
    # end_date = datetime.datetime.utcnow()
    # difference = end_date - start_date #The difference between now and J2000.0 start.
    # difference_yr = (difference.days + difference.seconds/86400.)/365.2425 #The difference in years between now and J2000.0 epoch.

    # #calculating the proper motion into Right Ascension and Declination
    # RA_pm * difference_yr *(1000) #now in arcseconds
    # DEC_pm * difference_yr *(1000) #now in arcseconds

    
    
    # #saves the proper motion in self
    # self.RAJ2000_pm = RA_pm
    # self.DECJ2000_pm = DEC_pm

    # if self.RAJ2000_pm !=RA_pm or self.DECJ2000_pm != DEC_pm:
    #     print(&#39;There was an error setting the proper motion&#39;)
    #     return False
    # ##############################################################

   
    #check if they are set correctly
    if self.RAJ2000 != RA or self.DECJ2000 != DEC:
        print(&#39;There was an error setting RA/DEC&#39;)
        return False
    

    print(&#39;The new coordinates have been set&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.startMntHoming"><code class="name flex">
<span>def <span class="ident">startMntHoming</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that starts the homing procedure in PWI4 for the mount.
<em>PLEASE NOTE</em>: Per version 0.0.1 this function crashes the simulator and
has not been tested on a real telescope. It is therefor suggested to be very careful when
using this function</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Per version 0.0.1</code></dt>
<dd>Nothing.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startMntHoming(self):
    &#34;&#34;&#34;
    A function that starts the homing procedure in PWI4 for the mount. 
    *PLEASE NOTE*: Per version 0.0.1 this function crashes the simulator and
    has not been tested on a real telescope. It is therefor suggested to be very careful when
    using this function

    Args:
        None
    
    Returns:
        Per version 0.0.1: Nothing.
    &#34;&#34;&#34;

    self.update()
    print(&#39;Starting homing of the mount - please wait&#39;)
    cmd = requests.get(self.link+&#39;mount/find_home&#39;)
    return cmd</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.startTracking"><code class="name flex">
<span>def <span class="ident">startTracking</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that starts the tracking. The mount will track the current position of the telescope/mount.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when tracking is on</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startTracking(self):
    &#34;&#34;&#34;
    A function that starts the tracking. The mount will track the current position of the telescope/mount.
    
    Args:
        None
    
    Returns:
        True when tracking is on
        False if there is a timeout
    &#34;&#34;&#34;
    print(&#39;Starting tracking - please wait&#39;)
    
    cmd = requests.get(self.link+&#34;mount/tracking_on&#34;)
    
    timeout_sec = 15 # number of seconds before timing out
    timeout = time.time() + timeout_sec
    time.sleep(1)
    self.update()
    while self.MNT_tracking == &#34;False&#34;:
        print(&#39;Not tracking yet - please wait&#39;)
        time.sleep(2)
        self.update()
        if time.time() &gt; timeout: 
            print(&#39;The session has timed out after %i seconds&#39;%(timeout_sec))
            return False
    print(&#39;Tracking is now on&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.stopTracking"><code class="name flex">
<span>def <span class="ident">stopTracking</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that stops the mount tracking a target.
The opposite function - "startTracking()" - starts the tracking.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True when tracking has stopped</code></dt>
<dd>&nbsp;</dd>
<dt><code>True if the mount has already stopped</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is a timeout</code></dt>
<dd>&nbsp;</dd>
<dt><code>False if there is an unknown error</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stopTracking(self):
    &#34;&#34;&#34;
    A function that stops the mount tracking a target. 
    The opposite function - &#34;startTracking()&#34; - starts the tracking.
    
    Returns:
        True when tracking has stopped
        True if the mount has already stopped
        False if there is a timeout
        False if there is an unknown error
        
    
    &#34;&#34;&#34;
    #self.update()
    #if self.MNT_tracking == &#34;false&#34;:
    #    print(&#39;The mount has already stopped tracking&#39;)
    #    return True


    stop = requests.get(self.link+&#34;mount/tracking_off&#34;)
    print(&#39;Stopping tracking request sent - please wait&#39;)
    self.update()
    timeout_sec = 20 #number of seconds before timeout
    timeout = time.time()+timeout_sec
    while self.MNT_tracking == &#34;true&#34;:
        print(&#39;Trying to stop tracking - please wait&#39;)
        time.sleep(1)
        self.update()
        if time.time() &gt; timeout:
            print(&#39;This session has timed-out after %i seconds&#39; %timeout_sec)
            return False
    if self.MNT_tracking == &#34;false&#34;:
        print(&#39;The tracking is OFF and the mount has stoppped.&#39;)
        time.sleep(3)
        self.update()
        print(&#39;The current position of the telescope is %g\xb0 %g\xb0 (Alt,Azm)&#39;%(float(self.MNT_Alt),float(self.MNT_Azm)))
    else: 
        print(&#39;Something went wrong trying to stop the tracking&#39;)
        return False
    return True</code></pre>
</details>
</dd>
<dt id="PW4.PWI4.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function runs the <strong>init</strong> function again to update the stored variables in self. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>True</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;
    This function runs the __init__ function again to update the stored variables in self. 
    
    Args:
        None

    Returns: 
        True
    
    &#34;&#34;&#34;
    self.__init__()
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PW4.PWI4" href="#PW4.PWI4">PWI4</a></code></h4>
<ul class="two-column">
<li><code><a title="PW4.PWI4.AddPointToModel" href="#PW4.PWI4.AddPointToModel">AddPointToModel</a></code></li>
<li><code><a title="PW4.PWI4.ClearPointingModel" href="#PW4.PWI4.ClearPointingModel">ClearPointingModel</a></code></li>
<li><code><a title="PW4.PWI4.ConnectFOC" href="#PW4.PWI4.ConnectFOC">ConnectFOC</a></code></li>
<li><code><a title="PW4.PWI4.ConnectMNT" href="#PW4.PWI4.ConnectMNT">ConnectMNT</a></code></li>
<li><code><a title="PW4.PWI4.DisconnectFOC" href="#PW4.PWI4.DisconnectFOC">DisconnectFOC</a></code></li>
<li><code><a title="PW4.PWI4.DisconnectMNT" href="#PW4.PWI4.DisconnectMNT">DisconnectMNT</a></code></li>
<li><code><a title="PW4.PWI4.FansOFF" href="#PW4.PWI4.FansOFF">FansOFF</a></code></li>
<li><code><a title="PW4.PWI4.FansON" href="#PW4.PWI4.FansON">FansON</a></code></li>
<li><code><a title="PW4.PWI4.FocSTOP" href="#PW4.PWI4.FocSTOP">FocSTOP</a></code></li>
<li><code><a title="PW4.PWI4.LoadPointingModel" href="#PW4.PWI4.LoadPointingModel">LoadPointingModel</a></code></li>
<li><code><a title="PW4.PWI4.MntMotorDisable" href="#PW4.PWI4.MntMotorDisable">MntMotorDisable</a></code></li>
<li><code><a title="PW4.PWI4.MntMotorEnable" href="#PW4.PWI4.MntMotorEnable">MntMotorEnable</a></code></li>
<li><code><a title="PW4.PWI4.MntMotorReset" href="#PW4.PWI4.MntMotorReset">MntMotorReset</a></code></li>
<li><code><a title="PW4.PWI4.MntMoveAltAzm" href="#PW4.PWI4.MntMoveAltAzm">MntMoveAltAzm</a></code></li>
<li><code><a title="PW4.PWI4.MntMoveRaDec" href="#PW4.PWI4.MntMoveRaDec">MntMoveRaDec</a></code></li>
<li><code><a title="PW4.PWI4.MntMoveRaDecJ2000" href="#PW4.PWI4.MntMoveRaDecJ2000">MntMoveRaDecJ2000</a></code></li>
<li><code><a title="PW4.PWI4.MountSTOP" href="#PW4.PWI4.MountSTOP">MountSTOP</a></code></li>
<li><code><a title="PW4.PWI4.MoveFocuserPos" href="#PW4.PWI4.MoveFocuserPos">MoveFocuserPos</a></code></li>
<li><code><a title="PW4.PWI4.RotSTOP" href="#PW4.PWI4.RotSTOP">RotSTOP</a></code></li>
<li><code><a title="PW4.PWI4.Rot_Move" href="#PW4.PWI4.Rot_Move">Rot_Move</a></code></li>
<li><code><a title="PW4.PWI4.Rot_derotateStart" href="#PW4.PWI4.Rot_derotateStart">Rot_derotateStart</a></code></li>
<li><code><a title="PW4.PWI4.Rot_derotateStop" href="#PW4.PWI4.Rot_derotateStop">Rot_derotateStop</a></code></li>
<li><code><a title="PW4.PWI4.SavePointingModel" href="#PW4.PWI4.SavePointingModel">SavePointingModel</a></code></li>
<li><code><a title="PW4.PWI4.checkFormatAltAzm" href="#PW4.PWI4.checkFormatAltAzm">checkFormatAltAzm</a></code></li>
<li><code><a title="PW4.PWI4.checkFormatArcsec" href="#PW4.PWI4.checkFormatArcsec">checkFormatArcsec</a></code></li>
<li><code><a title="PW4.PWI4.checkFormatRaDec" href="#PW4.PWI4.checkFormatRaDec">checkFormatRaDec</a></code></li>
<li><code><a title="PW4.PWI4.getALL" href="#PW4.PWI4.getALL">getALL</a></code></li>
<li><code><a title="PW4.PWI4.getDEC2000" href="#PW4.PWI4.getDEC2000">getDEC2000</a></code></li>
<li><code><a title="PW4.PWI4.getFOC_CONNECT" href="#PW4.PWI4.getFOC_CONNECT">getFOC_CONNECT</a></code></li>
<li><code><a title="PW4.PWI4.getFocuserPos" href="#PW4.PWI4.getFocuserPos">getFocuserPos</a></code></li>
<li><code><a title="PW4.PWI4.getIsTrackingOn" href="#PW4.PWI4.getIsTrackingOn">getIsTrackingOn</a></code></li>
<li><code><a title="PW4.PWI4.getMNT_CONNECT" href="#PW4.PWI4.getMNT_CONNECT">getMNT_CONNECT</a></code></li>
<li><code><a title="PW4.PWI4.getRA2000" href="#PW4.PWI4.getRA2000">getRA2000</a></code></li>
<li><code><a title="PW4.PWI4.getROT_CONNECT" href="#PW4.PWI4.getROT_CONNECT">getROT_CONNECT</a></code></li>
<li><code><a title="PW4.PWI4.getRotatorDerotate" href="#PW4.PWI4.getRotatorDerotate">getRotatorDerotate</a></code></li>
<li><code><a title="PW4.PWI4.getRotatorPos" href="#PW4.PWI4.getRotatorPos">getRotatorPos</a></code></li>
<li><code><a title="PW4.PWI4.getStatus" href="#PW4.PWI4.getStatus">getStatus</a></code></li>
<li><code><a title="PW4.PWI4.getTemps" href="#PW4.PWI4.getTemps">getTemps</a></code></li>
<li><code><a title="PW4.PWI4.getTrackingRMSError" href="#PW4.PWI4.getTrackingRMSError">getTrackingRMSError</a></code></li>
<li><code><a title="PW4.PWI4.parkMount" href="#PW4.PWI4.parkMount">parkMount</a></code></li>
<li><code><a title="PW4.PWI4.setTargetAltAzm" href="#PW4.PWI4.setTargetAltAzm">setTargetAltAzm</a></code></li>
<li><code><a title="PW4.PWI4.setTargetRaDec" href="#PW4.PWI4.setTargetRaDec">setTargetRaDec</a></code></li>
<li><code><a title="PW4.PWI4.setTargetRaDecJ2000" href="#PW4.PWI4.setTargetRaDecJ2000">setTargetRaDecJ2000</a></code></li>
<li><code><a title="PW4.PWI4.startMntHoming" href="#PW4.PWI4.startMntHoming">startMntHoming</a></code></li>
<li><code><a title="PW4.PWI4.startTracking" href="#PW4.PWI4.startTracking">startTracking</a></code></li>
<li><code><a title="PW4.PWI4.stopTracking" href="#PW4.PWI4.stopTracking">stopTracking</a></code></li>
<li><code><a title="PW4.PWI4.update" href="#PW4.PWI4.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>